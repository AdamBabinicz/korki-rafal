import {
  pgTable,
  text,
  serial,
  integer,
  boolean,
  timestamp,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  role: text("role").notNull().default("student"),
  name: text("name").notNull(),
  // Nowe pola:
  phone: text("phone"),
  address: text("address"),
});

export const slots = pgTable("slots", {
  id: serial("id").primaryKey(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  isBooked: boolean("is_booked").default(false).notNull(),
  studentId: integer("student_id").references(() => users.id),
  isPaid: boolean("is_paid").default(false).notNull(),
  topic: text("topic"),
  notes: text("notes"),
});

export const waitlist = pgTable("waitlist", {
  id: serial("id").primaryKey(),
  date: timestamp("date").notNull(),
  userId: integer("user_id")
    .references(() => users.id)
    .notNull(),
});

// Aktualizacja schematu walidacji, aby uwzględniał nowe pola
export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
  role: true,
  name: true,
  phone: true,
  address: true,
});

export const insertSlotSchema = createInsertSchema(slots).omit({
  id: true,
});

export const insertWaitlistSchema = createInsertSchema(waitlist).omit({
  id: true,
});

export const generateSlotsSchema = z.object({
  startDate: z.string(),
  endDate: z.string(),
  startTime: z.string(),
  endTime: z.string(),
  duration: z.number(),
});

export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type Slot = typeof slots.$inferSelect;
export type InsertSlot = z.infer<typeof insertSlotSchema>;
export type Waitlist = typeof waitlist.$inferSelect;
export type InsertWaitlist = z.infer<typeof insertWaitlistSchema>;
------------------------------
import { useState } from "react";
import { useRegister } from "@/hooks/use-auth";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Link } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { useTranslation } from "react-i18next";
import { Loader2 } from "lucide-react";

export default function RegisterPage() {
  const { t } = useTranslation();
  const [formData, setFormData] = useState({
    name: "",
    username: "",
    password: "",
    phone: "",
    address: "",
    role: "student" as const,
  });

  const { mutate: register, isPending } = useRegister();
  const { toast } = useToast();

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    register(formData, {
      onError: (err) => {
        toast({
          variant: "destructive",
          title: "Registration failed",
          description: err.message,
        });
      },
    });
  };

  return (
    <div className="min-h-screen grid place-items-center bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-secondary/20 via-background to-background p-4 py-8">
      <Card className="w-full max-w-md border-secondary/20 shadow-2xl shadow-secondary/10">
        <CardHeader className="text-center pb-4">
          <div className="mx-auto w-12 h-12 bg-gradient-to-br from-orange-500 to-primary rounded-xl mb-4 flex items-center justify-center text-white font-bold text-xl shadow-lg">
            M
          </div>
          <CardTitle className="text-3xl font-bold">
            {t("nav.register")}
          </CardTitle>
          <p className="text-muted-foreground mt-2">
            {t("auth.register_subtitle")}
          </p>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-3">
            <div className="space-y-2">
              <Label htmlFor="name">{t("auth.full_name")}</Label>
              <Input
                id="name"
                required
                placeholder={t("auth.name_placeholder")}
                value={formData.name}
                onChange={(e) =>
                  setFormData({ ...formData, name: e.target.value })
                }
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="username">{t("auth.username")}</Label>
                <Input
                  id="username"
                  required
                  placeholder={t("auth.username_placeholder")}
                  value={formData.username}
                  onChange={(e) =>
                    setFormData({ ...formData, username: e.target.value })
                  }
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="phone">Telefon</Label>
                <Input
                  id="phone"
                  required
                  placeholder="123-456-789"
                  value={formData.phone}
                  onChange={(e) =>
                    setFormData({ ...formData, phone: e.target.value })
                  }
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="address">Adres (Ulica, Miasto)</Label>
              <Input
                id="address"
                required
                placeholder="ul. Szkolna 5, Warszawa"
                value={formData.address}
                onChange={(e) =>
                  setFormData({ ...formData, address: e.target.value })
                }
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="password">{t("auth.password")}</Label>
              <Input
                id="password"
                required
                type="password"
                placeholder={t("auth.password_placeholder")}
                value={formData.password}
                onChange={(e) =>
                  setFormData({ ...formData, password: e.target.value })
                }
              />
            </div>
            <Button
              type="submit"
              className="w-full mt-4 font-bold bg-orange-500 hover:bg-orange-600 text-white"
              disabled={isPending}
              size="lg"
            >
              {isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              {t("nav.register")}
            </Button>
          </form>
          <div className="mt-6 text-center text-sm text-muted-foreground">
            {t("auth.has_account")}{" "}
            <Link href="/login">
              <a className="text-orange-500 hover:text-orange-600 font-semibold hover:underline cursor-pointer">
                {t("nav.login")}
              </a>
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
-------------------------
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import { storage } from "./storage";
import { User } from "@shared/schema";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedPasswordBuf = Buffer.from(hashed, "hex");
  const suppliedPasswordBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedPasswordBuf, suppliedPasswordBuf);
}

export function setupAuth(app: Express) {
  const sessionSettings: session.SessionOptions = {
    secret: process.env.SESSION_SECRET || "r3pl1t_s3cr3t",
    resave: false,
    saveUninitialized: false,
    store: storage.sessionStore,
    cookie: {
      secure: app.get("env") === "production",
      maxAge: 1000 * 60 * 60 * 24 * 30, // 30 days
    },
  };

  if (app.get("env") === "production") {
    app.set("trust proxy", 1);
  }

  app.use(session(sessionSettings));
  app.use(passport.initialize());
  app.use(passport.session());

  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        const user = await storage.getUserByUsername(username);
        if (!user) {
          return done(null, false);
        }

        const isValid = await comparePasswords(password, user.password);
        if (!isValid) {
          return done(null, false);
        }

        return done(null, user);
      } catch (err) {
        return done(err);
      }
    })
  );

  passport.serializeUser((user, done) => {
    done(null, (user as User).id);
  });

  passport.deserializeUser(async (id, done) => {
    try {
      const user = await storage.getUser(id as number);
      done(null, user);
    } catch (err) {
      done(err);
    }
  });

  app.post("/api/register", async (req, res, next) => {
    try {
      const existingUser = await storage.getUserByUsername(req.body.username);
      if (existingUser) {
        return res.status(400).send("Username already exists");
      }

      const hashedPassword = await hashPassword(req.body.password);
      const user = await storage.createUser({
        ...req.body,
        password: hashedPassword,
      });

      req.login(user, (err) => {
        if (err) return next(err);
        res.status(201).json(user);
      });
    } catch (err) {
      next(err);
    }
  });

  app.post("/api/login", passport.authenticate("local"), (req, res) => {
    res.status(200).json(req.user);
  });

  app.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });

  app.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    res.json(req.user);
  });
}
---------------------------------
import { db, pool } from "./db";
import {
  users,
  slots,
  waitlist,
  type User,
  type InsertUser,
  type Slot,
  type InsertSlot,
  type Waitlist,
  type InsertWaitlist,
} from "@shared/schema";
import { eq, and, gte, lte, asc } from "drizzle-orm";
import session from "express-session";
import connectPg from "connect-pg-simple";

const PostgresSessionStore = connectPg(session);

export interface IStorage {
  sessionStore: session.Store;

  // User
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Slots
  // Zmieniamy typ zwracany, aby uwzględniał studenta
  getSlots(
    start?: Date,
    end?: Date
  ): Promise<(Slot & { student?: User | null })[]>;
  getSlot(id: number): Promise<Slot | undefined>;
  createSlot(slot: InsertSlot): Promise<Slot>;
  updateSlot(id: number, updates: Partial<InsertSlot>): Promise<Slot>;
  deleteSlot(id: number): Promise<void>;

  // Waitlist
  addToWaitlist(entry: InsertWaitlist): Promise<Waitlist>;
  getWaitlist(date: Date): Promise<Waitlist[]>;
}

export class DatabaseStorage implements IStorage {
  sessionStore: session.Store;

  constructor() {
    this.sessionStore = new PostgresSessionStore({
      pool,
      createTableIfMissing: true,
    });
  }

  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.username, username));
    return user;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }

  async getSlots(
    start?: Date,
    end?: Date
  ): Promise<(Slot & { student?: User | null })[]> {
    let query = db
      .select({
        slot: slots,
        student: users,
      })
      .from(slots)
      .leftJoin(users, eq(slots.studentId, users.id))
      .orderBy(asc(slots.startTime));

    if (start && end) {
      // @ts-ignore - Drizzle query builder typing workaround
      query = query.where(
        and(gte(slots.startTime, start), lte(slots.startTime, end))
      );
    }

    const results = await query;

    // Spłaszczamy wynik, aby pasował do oczekiwań (Slot + pole student)
    return results.map(({ slot, student }) => ({
      ...slot,
      student: student || null,
    }));
  }

  async getSlot(id: number): Promise<Slot | undefined> {
    const [slot] = await db.select().from(slots).where(eq(slots.id, id));
    return slot;
  }

  async createSlot(slot: InsertSlot): Promise<Slot> {
    const [newSlot] = await db.insert(slots).values(slot).returning();
    return newSlot;
  }

  async updateSlot(id: number, updates: Partial<InsertSlot>): Promise<Slot> {
    const [updated] = await db
      .update(slots)
      .set(updates)
      .where(eq(slots.id, id))
      .returning();
    return updated;
  }

  async deleteSlot(id: number): Promise<void> {
    await db.delete(slots).where(eq(slots.id, id));
  }

  async addToWaitlist(entry: InsertWaitlist): Promise<Waitlist> {
    const [item] = await db.insert(waitlist).values(entry).returning();
    return item;
  }

  async getWaitlist(date: Date): Promise<Waitlist[]> {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);

    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    return await db
      .select()
      .from(waitlist)
      .where(and(gte(waitlist.date, startOfDay), lte(waitlist.date, endOfDay)));
  }
}

export const storage = new DatabaseStorage();
----------------------------------
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { type User, insertUserSchema } from "@shared/schema";
import { useLocation } from "wouter";
import { z } from "zod";
import { useToast } from "@/hooks/use-toast";

export function useUser() {
  return useQuery<User | null>({
    queryKey: ["/api/user"],
    queryFn: async () => {
      const res = await fetch("/api/user");
      if (res.status === 401) return null;
      if (!res.ok) throw new Error("Failed to fetch user");
      return await res.json();
    },
    retry: false,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useLogin() {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (credentials: { username: string; password: string }) => {
      const res = await fetch("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });

      if (!res.ok) {
        throw new Error("Invalid credentials");
      }
      return (await res.json()) as User;
    },
    onSuccess: (user) => {
      queryClient.setQueryData(["/api/user"], user);
      setLocation(user.role === "admin" ? "/admin" : "/dashboard");
      toast({
        title: "Welcome back!",
        description: `Logged in as ${user.username}`,
      });
    },
    onError: (error) => {
      toast({
        title: "Login failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

export function useRegister() {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: z.infer<typeof insertUserSchema>) => {
      const res = await fetch("/api/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(errorText || "Registration failed");
      }
      return (await res.json()) as User;
    },
    onSuccess: (user) => {
      queryClient.setQueryData(["/api/user"], user);
      setLocation(user.role === "admin" ? "/admin" : "/dashboard");
      toast({ title: "Welcome!", description: "Account created successfully" });
    },
    onError: (error) => {
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

export function useLogout() {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/logout", {
        method: "POST",
      });
      if (!res.ok) throw new Error("Logout failed");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
      setLocation("/");
      toast({ title: "Logged out", description: "See you next time!" });
    },
  });
}
---------------------------------
import { useTranslation } from "react-i18next";
import { useUser } from "@/hooks/use-auth";
import { useSlots } from "@/hooks/use-slots";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  format,
  differenceInDays,
  differenceInHours,
  parseISO,
  isAfter,
} from "date-fns";
import { pl, enUS } from "date-fns/locale";
import { Calendar, Clock, ArrowRight } from "lucide-react";
import { Link } from "wouter";

export default function Dashboard() {
  const { t, i18n } = useTranslation();
  const { data: user } = useUser();
  const { data: slots } = useSlots();
  const locale = i18n.language === "pl" ? pl : enUS;

  // Filtrowanie i sortowanie lekcji
  const upcomingLessons =
    slots
      ?.filter(
        (s) =>
          s.isBooked &&
          s.studentId === user?.id &&
          isAfter(new Date(s.startTime), new Date())
      )
      .sort(
        (a, b) =>
          new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
      ) || [];

  const nextLesson = upcomingLessons[0];

  const timeUntil = nextLesson
    ? {
        days: differenceInDays(new Date(nextLesson.startTime), new Date()),
        hours:
          differenceInHours(new Date(nextLesson.startTime), new Date()) % 24,
      }
    : null;

  return (
    <div className="container mx-auto p-6 space-y-8 pt-24 min-h-screen">
      <header className="space-y-2 animate-in fade-in slide-in-from-left-4 duration-500">
        <h1 className="text-4xl font-bold tracking-tight">
          {i18n.language === "pl"
            ? `Cześć, ${user?.name}!`
            : `Hello, ${user?.name}!`}
        </h1>
        <p className="text-muted-foreground">
          {i18n.language === "pl"
            ? "Miło Cię widzieć z powrotem. Gotowy na matematykę?"
            : "Good to see you back. Ready for some math?"}
        </p>
      </header>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {nextLesson && (
          <Card className="border-primary/20 bg-primary/5 animate-in zoom-in-95 duration-500">
            <CardHeader>
              <CardTitle className="text-sm font-medium text-primary uppercase tracking-wider flex items-center gap-2">
                <Clock className="w-4 h-4" />
                {t("dashboard.next_lesson")}
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold">
                {timeUntil?.days}d {timeUntil?.hours}h
              </div>
              <p className="text-xs text-muted-foreground mt-1">
                {format(new Date(nextLesson.startTime), "PPP p", { locale })}
              </p>
            </CardContent>
          </Card>
        )}

        <Card className="md:col-span-2 lg:col-span-3 border-border/50 shadow-sm">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Calendar className="w-5 h-5 text-primary" />
              {t("dashboard.upcoming")}
            </CardTitle>
          </CardHeader>
          <CardContent>
            {upcomingLessons.length > 0 ? (
              <div className="space-y-4">
                {upcomingLessons.map((lesson) => (
                  <div
                    key={lesson.id}
                    className="flex items-center justify-between p-4 rounded-lg border border-border bg-card hover:bg-muted/50 transition-colors"
                  >
                    <div className="space-y-1">
                      <p className="font-medium text-lg">
                        {lesson.topic ||
                          (i18n.language === "pl"
                            ? "Matematyka"
                            : "Mathematics")}
                      </p>
                      <p className="text-sm text-muted-foreground flex items-center gap-2">
                        <Clock className="w-4 h-4" />
                        {format(new Date(lesson.startTime), "PPPP p", {
                          locale,
                        })}
                      </p>
                    </div>
                    <Badge
                      variant={lesson.isPaid ? "default" : "outline"}
                      className={
                        lesson.isPaid ? "bg-green-500 hover:bg-green-600" : ""
                      }
                    >
                      {lesson.isPaid
                        ? i18n.language === "pl"
                          ? "Opłacone"
                          : "Paid"
                        : i18n.language === "pl"
                        ? "Nieopłacone"
                        : "Unpaid"}
                    </Badge>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-12 space-y-4">
                <p className="text-muted-foreground">
                  {t("dashboard.no_lessons")}
                </p>
                <Link href="/booking">
                  <Button variant="outline" className="cursor-pointer">
                    {i18n.language === "pl"
                      ? "Zarezerwuj pierwszą lekcję"
                      : "Book your first lesson"}
                    <ArrowRight className="ml-2 w-4 h-4" />
                  </Button>
                </Link>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
----------------------------------
import { useState } from "react";
import { useLogin } from "@/hooks/use-auth";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Link } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { useTranslation } from "react-i18next";
import { Loader2 } from "lucide-react";

export default function LoginPage() {
  const { t } = useTranslation();
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const { mutate: login, isPending } = useLogin();
  const { toast } = useToast();

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    login(
      { username, password },
      {
        onError: (err) => {
          toast({
            variant: "destructive",
            title: "Login failed",
            description: err.message,
          });
        },
      }
    );
  };

  return (
    <div className="min-h-screen grid place-items-center bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-primary/20 via-background to-background p-4">
      <Card className="w-full max-w-md border-primary/20 shadow-2xl shadow-primary/10">
        <CardHeader className="text-center pb-8">
          <div className="mx-auto w-12 h-12 bg-gradient-to-br from-primary to-orange-500 rounded-xl mb-4 flex items-center justify-center text-white font-bold text-xl shadow-lg">
            M
          </div>
          <CardTitle className="text-3xl font-bold">{t("nav.login")}</CardTitle>
          <p className="text-muted-foreground mt-2">
            {t("auth.login_subtitle")}
          </p>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username">{t("auth.username")}</Label>
              <Input
                id="username"
                required
                placeholder={t("auth.enter_username")}
                value={username}
                onChange={(e) => setUsername(e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">{t("auth.password")}</Label>
              <Input
                id="password"
                required
                type="password"
                placeholder={t("auth.enter_password")}
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <Button
              type="submit"
              className="w-full mt-4 font-bold"
              disabled={isPending}
              size="lg"
            >
              {isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              {t("auth.submit")}
            </Button>
          </form>
          <div className="mt-6 text-center text-sm text-muted-foreground">
            {t("auth.no_account")}{" "}
            <Link href="/register">
              <a className="text-primary hover:text-primary/80 font-semibold hover:underline cursor-pointer">
                {t("nav.register")}
              </a>
            </Link>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
---------------------------------
import { useState } from "react";
import { useSlots, useBookSlot, useCancelSlot } from "@/hooks/use-slots";
import { useUser } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  format,
  startOfWeek,
  addWeeks,
  subWeeks,
  isBefore,
  addHours,
} from "date-fns";
import { pl, enUS } from "date-fns/locale";
import { Loader2, ChevronLeft, ChevronRight } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { useTranslation } from "react-i18next";

export default function BookingPage() {
  const { t, i18n } = useTranslation();
  const [currentWeek, setCurrentWeek] = useState(new Date());
  const [selectedSlot, setSelectedSlot] = useState<any>(null);
  const [bookingTopic, setBookingTopic] = useState("");

  const { data: user } = useUser();
  const { data: slots, isLoading } = useSlots();
  const { mutate: bookSlot, isPending: isBooking } = useBookSlot();
  const { mutate: cancelSlot } = useCancelSlot();
  const { toast } = useToast();

  const locale = i18n.language === "pl" ? pl : enUS;

  const handleBook = () => {
    if (!selectedSlot) return;

    bookSlot(selectedSlot.id, {
      onSuccess: () => {
        toast({
          title: t("booking.success"),
          description: t("booking.success_desc"),
        });
        setSelectedSlot(null);
        setBookingTopic("");
      },
    });
  };

  const handleCancel = (slot: any) => {
    const slotTime = new Date(slot.startTime);
    // Guard 24h na froncie
    if (isBefore(slotTime, addHours(new Date(), 24))) {
      toast({
        variant: "destructive",
        title: t("booking.cancel_error_title"),
        description: t("booking.cancel_error_desc"),
      });
      return;
    }

    if (confirm(t("booking.cancel_confirm"))) {
      cancelSlot(slot.id);
    }
  };

  const startOfCurrentWeek = startOfWeek(currentWeek, { weekStartsOn: 1 });

  const weekDates = Array.from({ length: 7 }).map((_, i) => {
    const d = new Date(startOfCurrentWeek);
    d.setDate(d.getDate() + i);
    return d;
  });

  if (isLoading)
    return (
      <div className="min-h-screen grid place-items-center">
        <Loader2 className="animate-spin w-10 h-10 text-primary" />
      </div>
    );

  return (
    <div className="min-h-screen bg-background pt-24 pb-12 px-4">
      <div className="max-w-7xl mx-auto space-y-8">
        <div className="flex flex-col md:flex-row justify-between items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold">{t("booking.title")}</h1>
            <p className="text-muted-foreground">{t("booking.subtitle")}</p>
          </div>
          <div className="flex items-center gap-2 bg-card p-1 rounded-xl border border-border">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setCurrentWeek(subWeeks(currentWeek, 1))}
            >
              <ChevronLeft className="w-5 h-5" />
            </Button>
            <span className="px-4 font-medium min-w-[140px] text-center capitalize">
              {format(startOfCurrentWeek, "MMM d", { locale })} -{" "}
              {format(weekDates[6], "MMM d", { locale })}
            </span>
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setCurrentWeek(addWeeks(currentWeek, 1))}
            >
              <ChevronRight className="w-5 h-5" />
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-7 gap-4">
          {weekDates.map((date) => {
            const dateStr = format(date, "yyyy-MM-dd");
            const isToday = dateStr === format(new Date(), "yyyy-MM-dd");
            const dailySlots =
              slots
                ?.filter(
                  (s) => format(new Date(s.startTime), "yyyy-MM-dd") === dateStr
                )
                .sort(
                  (a, b) =>
                    new Date(a.startTime).getTime() -
                    new Date(b.startTime).getTime()
                ) || [];

            return (
              <div
                key={dateStr}
                className={`space-y-3 ${
                  isToday ? "bg-primary/5 rounded-2xl p-2 -m-2" : ""
                }`}
              >
                <div className="text-center mb-4">
                  <div className="text-sm text-muted-foreground uppercase font-bold">
                    {format(date, "EEE", { locale })}
                  </div>
                  <div
                    className={`text-2xl font-bold ${
                      isToday ? "text-primary" : ""
                    }`}
                  >
                    {format(date, "d")}
                  </div>
                </div>

                {dailySlots.length === 0 ? (
                  <div className="text-center py-4 text-sm text-muted-foreground/50">
                    {t("booking.no_slots")}
                  </div>
                ) : (
                  dailySlots.map((slot) => {
                    const isMyBooking = slot.studentId === user?.id;
                    const isBookedOther = slot.isBooked && !isMyBooking;

                    if (isBookedOther)
                      return (
                        <div
                          key={slot.id}
                          className="p-3 rounded-xl bg-muted/50 border border-border opacity-50 cursor-not-allowed text-center"
                        >
                          <span className="text-sm font-medium line-through decoration-muted-foreground/50 text-muted-foreground">
                            {format(new Date(slot.startTime), "HH:mm")}
                          </span>
                        </div>
                      );

                    if (isMyBooking)
                      return (
                        <button
                          key={slot.id}
                          onClick={() => handleCancel(slot)}
                          className="w-full p-3 rounded-xl bg-orange-500 text-white shadow-lg shadow-orange-500/20 hover:bg-orange-600 transition-all flex flex-col items-center group relative overflow-hidden"
                        >
                          <span className="text-sm font-bold relative z-10">
                            {format(new Date(slot.startTime), "HH:mm")}
                          </span>
                          <span className="text-[10px] opacity-90 relative z-10">
                            {t("booking.your_booking")}
                          </span>
                          <div className="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300" />
                        </button>
                      );

                    return (
                      <button
                        key={slot.id}
                        onClick={() => setSelectedSlot(slot)}
                        className="w-full p-3 rounded-xl bg-card border border-primary/20 hover:border-primary hover:bg-primary/5 transition-all group"
                      >
                        <span className="text-sm font-bold text-primary group-hover:scale-110 block transition-transform">
                          {format(new Date(slot.startTime), "HH:mm")}
                        </span>
                      </button>
                    );
                  })
                )}
              </div>
            );
          })}
        </div>
      </div>

      <Dialog
        open={!!selectedSlot}
        onOpenChange={(open) => !open && setSelectedSlot(null)}
      >
        <DialogContent className="bg-card border-border sm:max-w-md">
          <DialogHeader>
            <DialogTitle>{t("booking.confirm_title")}</DialogTitle>
          </DialogHeader>
          <div className="py-4 space-y-4">
            <div className="bg-muted p-4 rounded-xl border border-border">
              <p className="text-sm text-muted-foreground">
                {t("booking.time")}
              </p>
              <p className="text-xl font-bold capitalize">
                {selectedSlot &&
                  format(
                    new Date(selectedSlot.startTime),
                    "EEEE, d MMMM, HH:mm",
                    { locale }
                  )}
              </p>
            </div>

            <div className="space-y-2">
              <Label>{t("booking.topic_label")}</Label>
              <Input
                placeholder={t("booking.topic_placeholder")}
                value={bookingTopic}
                onChange={(e) => setBookingTopic(e.target.value)}
              />
            </div>

            <div className="flex justify-end gap-3 pt-4">
              <Button variant="ghost" onClick={() => setSelectedSlot(null)}>
                {t("booking.cancel_btn")}
              </Button>
              <Button onClick={handleBook} disabled={isBooking}>
                {isBooking && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                {t("booking.confirm_btn")}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
--------------------------------------
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  type Slot,
  type InsertSlot,
  generateSlotsSchema,
  insertSlotSchema,
} from "@shared/schema";
import { z } from "zod";
import { useToast } from "@/hooks/use-toast"; // Zakładam, że masz ten hook z shadcn/ui

export function useSlots(filters?: { start?: string; end?: string }) {
  return useQuery({
    queryKey: ["/api/slots", filters],
    queryFn: async () => {
      let url = "/api/slots";
      if (filters) {
        const params = new URLSearchParams();
        if (filters.start) params.append("start", filters.start);
        if (filters.end) params.append("end", filters.end);
        url += `?${params.toString()}`;
      }
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch slots");
      return (await res.json()) as Slot[];
    },
    refetchOnWindowFocus: true, // Smart polling
  });
}

export function useCreateSlot() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: InsertSlot) => {
      const res = await fetch("/api/slots", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to create slot");
      return (await res.json()) as Slot;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/slots"] });
      toast({ title: "Success", description: "Slot created successfully" });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

export function useGenerateSlots() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: z.infer<typeof generateSlotsSchema>) => {
      const res = await fetch("/api/slots/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error("Failed to generate slots");
      return await res.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/slots"] });
      toast({ title: "Success", description: `Generated ${data.count} slots` });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

export function useUpdateSlot() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async ({
      id,
      updates,
    }: {
      id: number;
      updates: Partial<InsertSlot>;
    }) => {
      const res = await fetch(`/api/slots/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updates),
      });
      if (!res.ok) throw new Error("Failed to update slot");
      return (await res.json()) as Slot;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/slots"] });
      toast({ title: "Success", description: "Slot updated" });
    },
  });
}

export function useDeleteSlot() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (id: number) => {
      const res = await fetch(`/api/slots/${id}`, {
        method: "DELETE",
      });
      if (!res.ok) throw new Error("Failed to delete slot");
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/slots"] });
      toast({ title: "Success", description: "Slot deleted" });
    },
  });
}

export function useBookSlot() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (id: number) => {
      const res = await fetch(`/api/slots/${id}/book`, {
        method: "POST",
      });
      if (!res.ok) throw new Error(await res.text());
      return (await res.json()) as Slot;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/slots"] });
      toast({ title: "Booking Confirmed", description: "See you in class!" });
    },
    onError: (error) => {
      toast({
        title: "Booking Failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

export function useCancelSlot() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (id: number) => {
      const res = await fetch(`/api/slots/${id}/cancel`, {
        method: "POST",
      });
      if (!res.ok) {
        const errorData = await res
          .json()
          .catch(() => ({ message: "Failed to cancel" }));
        throw new Error(errorData.message || "Failed to cancel");
      }
      return (await res.json()) as Slot;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/slots"] });
      toast({ title: "Cancelled", description: "Reservation cancelled." });
    },
    onError: (error) => {
      toast({
        title: "Cancellation Failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

-------------------------------------
import type { Express } from "express";
import type { Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";
import {
  insertSlotSchema,
  generateSlotsSchema,
  insertWaitlistSchema,
  insertWeeklyScheduleSchema,
  generateFromTemplateSchema,
  type User,
} from "@shared/schema";
import { z } from "zod";
import {
  addDays,
  setHours,
  setMinutes,
  parseISO,
  differenceInHours,
  format,
  getYear,
} from "date-fns";
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

// Funkcja pomocnicza do pobierania świąt w Polsce
async function getPublicHolidays(year: number): Promise<Set<string>> {
  try {
    const response = await fetch(
      `https://date.nager.at/api/v3/PublicHolidays/${year}/PL`
    );
    if (!response.ok) return new Set();
    const data = (await response.json()) as { date: string }[];
    return new Set(data.map((h) => h.date));
  } catch (error) {
    console.error("Failed to fetch holidays:", error);
    return new Set();
  }
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  setupAuth(app);

  // --- USERS (Admin only) ---
  app.get("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const users = await storage.getAllUsers();
    res.json(users);
  });

  // --- SLOTY (CRUD) ---

  app.get("/api/slots", async (req, res) => {
    const start = req.query.start
      ? new Date(req.query.start as string)
      : undefined;
    const end = req.query.end ? new Date(req.query.end as string) : undefined;
    const slots = await storage.getSlots(start, end);
    res.json(slots);
  });

  app.post("/api/slots", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertSlotSchema.parse(req.body);
      const slot = await storage.createSlot(input);
      res.status(201).json(slot);
    } catch (err) {
      if (err instanceof z.ZodError)
        res.status(400).json({ message: err.message });
      else res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const id = parseInt(req.params.id);
      const input = insertSlotSchema.partial().parse(req.body);
      const updated = await storage.updateSlot(id, input);
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Failed to update slot" });
    }
  });

  app.delete("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteSlot(id);
    res.sendStatus(204);
  });

  // --- SZABLON TYGODNIOWY (Weekly Schedule) ---

  app.get("/api/weekly-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const schedule = await storage.getWeeklySchedule();
    res.json(schedule);
  });

  app.post("/api/weekly-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertWeeklyScheduleSchema.parse(req.body);
      const item = await storage.createWeeklyScheduleItem(input);
      res.status(201).json(item);
    } catch (err) {
      if (err instanceof z.ZodError)
        res.status(400).json({ message: err.message });
      else res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/weekly-schedule/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteWeeklyScheduleItem(id);
    res.sendStatus(204);
  });

  // --- GENERATORY ---

  // Stary generator (prosty zakres godzin)
  app.post("/api/slots/generate", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const { startDate, endDate, startTime, endTime, duration } =
        generateSlotsSchema.parse(req.body);

      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const existingSlots = await storage.getSlots(start, addDays(end, 1));
      const existingTimestamps = new Set(
        existingSlots.map((s) => s.startTime.getTime())
      );

      const [startHour, startMinute] = startTime.split(":").map(Number);
      const [endHour, endMinute] = endTime.split(":").map(Number);

      let currentDay = start;
      let count = 0;

      while (currentDay <= end) {
        if (currentDay.getDay() !== 0 && currentDay.getDay() !== 6) {
          let daySlotStart = setMinutes(
            setHours(currentDay, startHour),
            startMinute
          );
          const daySlotEnd = setMinutes(
            setHours(currentDay, endHour),
            endMinute
          );

          while (daySlotStart < daySlotEnd) {
            const slotEnd = new Date(daySlotStart.getTime() + duration * 60000);
            if (slotEnd > daySlotEnd) break;

            if (!existingTimestamps.has(daySlotStart.getTime())) {
              await storage.createSlot({
                startTime: daySlotStart,
                endTime: slotEnd,
                isBooked: false,
                isPaid: false,
              });
              count++;
            }
            daySlotStart = slotEnd;
          }
        }
        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({ count });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate slots" });
    }
  });

  // NOWY GENERATOR: Z Szablonu (z obsługą świąt)
  app.post("/api/slots/generate-from-template", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const { startDate, endDate } = generateFromTemplateSchema.parse(req.body);
      const start = parseISO(startDate);
      const end = parseISO(endDate);

      // 1. Pobierz szablon tygodniowy
      const template = await storage.getWeeklySchedule();
      if (template.length === 0) {
        return res
          .status(400)
          .json({ message: "Szablon jest pusty. Zdefiniuj najpierw grafik." });
      }

      // 2. Pobierz święta (dla roku startu i końca, jeśli przełom lat)
      const startYear = getYear(start);
      const endYear = getYear(end);
      const holidays = await getPublicHolidays(startYear);
      if (startYear !== endYear) {
        const nextYearHolidays = await getPublicHolidays(endYear);
        nextYearHolidays.forEach((h) => holidays.add(h));
      }

      // 3. Sprawdź istniejące sloty, aby uniknąć duplikatów
      const existingSlots = await storage.getSlots(start, addDays(end, 1));
      const existingTimestamps = new Set(
        existingSlots.map((s) => s.startTime.getTime())
      );

      let currentDay = start;
      let count = 0;

      // 4. Pętla po dniach
      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");

        // Pomiń, jeśli święto
        if (holidays.has(dateStr)) {
          console.log(`Skipping holiday: ${dateStr}`);
          currentDay = addDays(currentDay, 1);
          continue;
        }

        const dayOfWeek = currentDay.getDay(); // 0 = Niedziela, 1 = Poniedziałek...
        // Pobierz elementy szablonu dla tego dnia tygodnia
        const dayTemplates = template.filter((t) => t.dayOfWeek === dayOfWeek);

        for (const item of dayTemplates) {
          const [hours, minutes] = item.startTime.split(":").map(Number);
          const slotStart = setMinutes(setHours(currentDay, hours), minutes);
          const slotEnd = new Date(
            slotStart.getTime() + item.durationMinutes * 60000
          );

          // Sprawdź duplikat
          if (!existingTimestamps.has(slotStart.getTime())) {
            await storage.createSlot({
              startTime: slotStart,
              endTime: slotEnd,
              isBooked: !!item.studentId, // Jeśli szablon ma studenta, od razu zajęty
              studentId: item.studentId, // Przypisz studenta z szablonu
              isPaid: false,
              price: item.price, // Przepisz cenę z szablonu
              topic: item.studentId ? "Stała lekcja" : undefined,
            });
            count++;
          }
        }

        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({ count, message: `Wygenerowano ${count} slotów.` });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate schedule" });
    }
  });

  // --- REZERWACJE / ANULOWANIE ---

  app.post("/api/slots/:id/book", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);

      if (!slot) return res.status(404).send("Slot not found");
      if (slot.isBooked) return res.status(409).send("Slot already booked");

      const updated = await storage.updateSlot(id, {
        isBooked: true,
        studentId: user.id,
      });
      res.json(updated);
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error";
      res.status(500).send(message);
    }
  });

  app.post("/api/slots/:id/cancel", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);

      if (!slot) return res.status(404).send("Slot not found");

      if (user.role !== "admin" && slot.studentId !== user.id) {
        return res.status(403).send("Not authorized");
      }

      if (user.role !== "admin") {
        const hoursUntilLesson = differenceInHours(
          new Date(slot.startTime),
          new Date()
        );
        if (hoursUntilLesson < 24) {
          return res.status(400).json({
            message: "Too late to cancel. Contact admin directly.",
          });
        }
      }

      const updated = await storage.updateSlot(id, {
        isBooked: false,
        studentId: null,
        isPaid: false,
      });
      res.json(updated);
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error";
      res.status(500).send(message);
    }
  });

  app.post("/api/waitlist", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;
    try {
      const input = insertWaitlistSchema.parse({
        ...req.body,
        userId: user.id,
      });
      const entry = await storage.addToWaitlist(input);
      res.status(201).json(entry);
    } catch (err) {
      res.status(400).json({ message: "Invalid request" });
    }
  });

  if (process.env.NODE_ENV !== "production") {
    const adminUser = await storage.getUserByUsername("admin");
    if (!adminUser) {
      const adminPass = await hashPassword("admin123");
      await storage.createUser({
        username: "admin",
        password: adminPass,
        role: "admin",
        name: "Math Tutor",
      });

      const studentPass = await hashPassword("student123");
      await storage.createUser({
        username: "student",
        password: studentPass,
        role: "student",
        name: "John Student",
      });
    }
  }

  return httpServer;
}
---------------------------------------
import type { Express } from "express";
import type { Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";
import {
  insertSlotSchema,
  generateSlotsSchema,
  insertWaitlistSchema,
  insertWeeklyScheduleSchema,
  generateFromTemplateSchema,
  type User,
} from "@shared/schema";
import { z } from "zod";
import {
  addDays,
  setHours,
  setMinutes,
  parseISO,
  differenceInHours,
  format,
  getYear,
} from "date-fns";
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

// Funkcja pomocnicza do pobierania świąt w Polsce
async function getPublicHolidays(year: number): Promise<Set<string>> {
  try {
    const response = await fetch(
      `https://date.nager.at/api/v3/PublicHolidays/${year}/PL`
    );
    if (!response.ok) return new Set();
    const data = (await response.json()) as { date: string }[];
    return new Set(data.map((h) => h.date));
  } catch (error) {
    console.error("Failed to fetch holidays:", error);
    return new Set();
  }
}

// --- DANE DO IMPORTU Z OBRAZKÓW ---
const SCHEDULE_DATA = [
  // PONIEDZIAŁEK (1)
  { day: 1, start: "11:00", duration: 60, price: 80, name: "Masia S." },
  { day: 1, start: "13:30", duration: 60, price: 80, name: "Natasza Z." },
  { day: 1, start: "14:50", duration: 60, price: 80, name: "Marcel M." },
  { day: 1, start: "16:30", duration: 60, price: 80, name: "Martyna S." },
  { day: 1, start: "17:50", duration: 60, price: 80, name: "Ksawery D." },
  { day: 1, start: "19:00", duration: 60, price: 80, name: "Filip B." },

  // WTOREK (2)
  { day: 2, start: "12:00", duration: 120, price: 160, name: "Julka B." }, // 2h
  { day: 2, start: "14:30", duration: 60, price: 80, name: "Oskar Z." },
  { day: 2, start: "16:20", duration: 60, price: 80, name: "Wiktor B." },
  { day: 2, start: "18:00", duration: 60, price: 90, name: "Julka S." },
  { day: 2, start: "19:00", duration: 60, price: 90, name: "Tobiasz S." },

  // ŚRODA (3)
  { day: 3, start: "12:00", duration: 60, price: 80, name: "Franek L." },
  { day: 3, start: "14:40", duration: 60, price: 80, name: "Mateusz M." },
  { day: 3, start: "16:15", duration: 90, price: 120, name: "Olek P." }, // 1.5h
  { day: 3, start: "18:00", duration: 60, price: 80, name: "Olek Ś." },

  // CZWARTEK (4)
  { day: 4, start: "12:10", duration: 60, price: 80, name: "Ola S." },
  { day: 4, start: "14:50", duration: 60, price: 80, name: "Michał G." },
  { day: 4, start: "16:30", duration: 60, price: 90, name: "Paweł S." },
  { day: 4, start: "17:45", duration: 60, price: 80, name: "Małgosia K." },
  { day: 4, start: "19:00", duration: 60, price: 80, name: "Adam L." },

  // PIĄTEK (5)
  { day: 5, start: "13:30", duration: 60, price: 80, name: "Oskar Z." }, // Ten sam co we wtorek
  { day: 5, start: "14:30", duration: 60, price: 80, name: "Pola M." },
  { day: 5, start: "16:30", duration: 60, price: 80, name: "Natalia B." },
  { day: 5, start: "18:00", duration: 120, price: 160, name: "Kacper M." }, // 2h

  // SOBOTA (6)
  { day: 6, start: "08:45", duration: 90, price: 120, name: "Michał W." }, // 1.5h
  { day: 6, start: "10:30", duration: 120, price: 160, name: "Oliwia P." }, // 2h
  { day: 6, start: "13:00", duration: 60, price: 80, name: "Kacper D." },
  { day: 6, start: "14:30", duration: 60, price: 80, name: "Janek P." },
  { day: 6, start: "15:30", duration: 60, price: 80, name: "Oskar N." },
  { day: 6, start: "17:00", duration: 90, price: 140, name: "Antek Ż." }, // 1.5h
];

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  setupAuth(app);

  // --- AUTOMATYCZNY IMPORT DANYCH (SEED) ---
  app.get("/api/admin/seed-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized. Log in as admin first.");
    }

    try {
      let usersCreated = 0;
      let scheduleItemsCreated = 0;
      const defaultPassword = await hashPassword("student123");

      for (const item of SCHEDULE_DATA) {
        // 1. Generowanie username (np. "Masia S." -> "masias")
        const normalizedName = item.name
          .toLowerCase()
          .replace(/ł/g, "l")
          .replace(/ś/g, "s")
          .replace(/ą/g, "a")
          .replace(/ę/g, "e")
          .replace(/ó/g, "o")
          .replace(/ż/g, "z")
          .replace(/ź/g, "z")
          .replace(/ć/g, "c")
          .replace(/ń/g, "n")
          .replace(/[^a-z0-9]/g, "");

        const username = normalizedName;

        // 2. Sprawdź czy user istnieje, jak nie to stwórz
        let student = await storage.getUserByUsername(username);
        if (!student) {
          student = await storage.createUser({
            username,
            password: defaultPassword,
            name: item.name,
            role: "student",
            defaultPrice: item.price,
            adminNotes: "Zaimportowano automatycznie",
          });
          usersCreated++;
        }

        // 3. Dodaj do harmonogramu tygodniowego
        await storage.createWeeklyScheduleItem({
          dayOfWeek: item.day,
          startTime: item.start,
          durationMinutes: item.duration,
          price: item.price,
          studentId: student.id,
        });
        scheduleItemsCreated++;
      }

      res.json({
        message: "Seed completed successfully",
        usersCreated,
        scheduleItemsCreated,
      });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Seed failed", error: String(err) });
    }
  });

  // --- RESZTA ENDPOINTÓW ---

  app.get("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const users = await storage.getAllUsers();
    res.json(users);
  });

  app.get("/api/slots", async (req, res) => {
    const start = req.query.start
      ? new Date(req.query.start as string)
      : undefined;
    const end = req.query.end ? new Date(req.query.end as string) : undefined;
    const slots = await storage.getSlots(start, end);
    res.json(slots);
  });

  app.post("/api/slots", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertSlotSchema.parse(req.body);
      const slot = await storage.createSlot(input);
      res.status(201).json(slot);
    } catch (err) {
      if (err instanceof z.ZodError)
        res.status(400).json({ message: err.message });
      else res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const id = parseInt(req.params.id);
      const input = insertSlotSchema.partial().parse(req.body);
      const updated = await storage.updateSlot(id, input);
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Failed to update slot" });
    }
  });

  app.delete("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteSlot(id);
    res.sendStatus(204);
  });

  // --- SZABLON TYGODNIOWY (Weekly Schedule) ---

  app.get("/api/weekly-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const schedule = await storage.getWeeklySchedule();
    res.json(schedule);
  });

  app.post("/api/weekly-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertWeeklyScheduleSchema.parse(req.body);
      const item = await storage.createWeeklyScheduleItem(input);
      res.status(201).json(item);
    } catch (err) {
      if (err instanceof z.ZodError)
        res.status(400).json({ message: err.message });
      else res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/weekly-schedule/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteWeeklyScheduleItem(id);
    res.sendStatus(204);
  });

  // --- GENERATORY ---

  app.post("/api/slots/generate", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const { startDate, endDate, startTime, endTime, duration } =
        generateSlotsSchema.parse(req.body);

      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const existingSlots = await storage.getSlots(start, addDays(end, 1));
      const existingTimestamps = new Set(
        existingSlots.map((s) => s.startTime.getTime())
      );

      const [startHour, startMinute] = startTime.split(":").map(Number);
      const [endHour, endMinute] = endTime.split(":").map(Number);

      let currentDay = start;
      let count = 0;

      while (currentDay <= end) {
        if (currentDay.getDay() !== 0 && currentDay.getDay() !== 6) {
          let daySlotStart = setMinutes(
            setHours(currentDay, startHour),
            startMinute
          );
          const daySlotEnd = setMinutes(
            setHours(currentDay, endHour),
            endMinute
          );

          while (daySlotStart < daySlotEnd) {
            const slotEnd = new Date(daySlotStart.getTime() + duration * 60000);
            if (slotEnd > daySlotEnd) break;

            if (!existingTimestamps.has(daySlotStart.getTime())) {
              await storage.createSlot({
                startTime: daySlotStart,
                endTime: slotEnd,
                isBooked: false,
                isPaid: false,
              });
              count++;
            }
            daySlotStart = slotEnd;
          }
        }
        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({ count });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate slots" });
    }
  });

  // NOWY GENERATOR: Z Szablonu (z obsługą świąt)
  app.post("/api/slots/generate-from-template", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const { startDate, endDate } = generateFromTemplateSchema.parse(req.body);
      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const template = await storage.getWeeklySchedule();
      if (template.length === 0) {
        return res
          .status(400)
          .json({ message: "Szablon jest pusty. Zdefiniuj najpierw grafik." });
      }

      const startYear = getYear(start);
      const endYear = getYear(end);
      const holidays = await getPublicHolidays(startYear);
      if (startYear !== endYear) {
        const nextYearHolidays = await getPublicHolidays(endYear);
        nextYearHolidays.forEach((h) => holidays.add(h));
      }

      const existingSlots = await storage.getSlots(start, addDays(end, 1));
      const existingTimestamps = new Set(
        existingSlots.map((s) => s.startTime.getTime())
      );

      let currentDay = start;
      let count = 0;

      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");

        if (holidays.has(dateStr)) {
          console.log(`Skipping holiday: ${dateStr}`);
          currentDay = addDays(currentDay, 1);
          continue;
        }

        const dayOfWeek = currentDay.getDay();
        const dayTemplates = template.filter((t) => t.dayOfWeek === dayOfWeek);

        for (const item of dayTemplates) {
          const [hours, minutes] = item.startTime.split(":").map(Number);
          const slotStart = setMinutes(setHours(currentDay, hours), minutes);
          const slotEnd = new Date(
            slotStart.getTime() + item.durationMinutes * 60000
          );

          if (!existingTimestamps.has(slotStart.getTime())) {
            await storage.createSlot({
              startTime: slotStart,
              endTime: slotEnd,
              isBooked: !!item.studentId,
              studentId: item.studentId,
              isPaid: false,
              price: item.price,
              topic: item.studentId ? "Stała lekcja" : undefined,
            });
            count++;
          }
        }

        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({ count, message: `Wygenerowano ${count} slotów.` });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate schedule" });
    }
  });

  app.post("/api/slots/:id/book", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);

      if (!slot) return res.status(404).send("Slot not found");
      if (slot.isBooked) return res.status(409).send("Slot already booked");

      const updated = await storage.updateSlot(id, {
        isBooked: true,
        studentId: user.id,
      });
      res.json(updated);
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error";
      res.status(500).send(message);
    }
  });

  app.post("/api/slots/:id/cancel", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);

      if (!slot) return res.status(404).send("Slot not found");

      if (user.role !== "admin" && slot.studentId !== user.id) {
        return res.status(403).send("Not authorized");
      }

      if (user.role !== "admin") {
        const hoursUntilLesson = differenceInHours(
          new Date(slot.startTime),
          new Date()
        );
        if (hoursUntilLesson < 24) {
          return res.status(400).json({
            message: "Too late to cancel. Contact admin directly.",
          });
        }
      }

      const updated = await storage.updateSlot(id, {
        isBooked: false,
        studentId: null,
        isPaid: false,
      });
      res.json(updated);
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error";
      res.status(500).send(message);
    }
  });

  app.post("/api/waitlist", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;
    try {
      const input = insertWaitlistSchema.parse({
        ...req.body,
        userId: user.id,
      });
      const entry = await storage.addToWaitlist(input);
      res.status(201).json(entry);
    } catch (err) {
      res.status(400).json({ message: "Invalid request" });
    }
  });

  if (process.env.NODE_ENV !== "production") {
    const adminUser = await storage.getUserByUsername("admin");
    if (!adminUser) {
      const adminPass = await hashPassword("admin123");
      await storage.createUser({
        username: "admin",
        password: adminPass,
        role: "admin",
        name: "Math Tutor",
      });
    }
  }

  return httpServer;
}
-------------------------------------
import { useState } from "react";
import {
  useSlots,
  useGenerateSlotsFromTemplate,
  useDeleteSlot,
  useUpdateSlot,
} from "@/hooks/use-slots";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  format,
  startOfWeek,
  endOfWeek,
  addDays,
  eachDayOfInterval,
  addWeeks,
  subWeeks,
} from "date-fns";
import { pl, enUS } from "date-fns/locale";
import {
  Loader2,
  Plus,
  Trash2,
  CheckCircle,
  Ban,
  ChevronLeft,
  ChevronRight,
  User,
  Phone,
  MapPin,
  Calendar as CalendarIcon,
  Copy,
  Users,
} from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Label } from "@/components/ui/label";
import { useTranslation } from "react-i18next";
import { WeeklySchedule, User as UserType } from "@shared/schema";

export default function AdminPanel() {
  const { t, i18n } = useTranslation();
  const [selectedDate, setSelectedDate] = useState(new Date());
  const { data: slots, isLoading: loadingSlots } = useSlots();
  const { mutate: deleteSlot } = useDeleteSlot();
  const { mutate: updateSlot } = useUpdateSlot();
  const { mutate: generateFromTemplate, isPending: isGenerating } =
    useGenerateSlotsFromTemplate();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Pobieranie uczniów
  const { data: students, isLoading: loadingStudents } = useQuery<UserType[]>({
    queryKey: ["/api/users"],
  });

  // Pobieranie szablonu tygodniowego
  const { data: weeklySchedule, isLoading: loadingSchedule } = useQuery<
    (WeeklySchedule & { student?: UserType | null })[]
  >({
    queryKey: ["/api/weekly-schedule"],
  });

  // Mutacja dodawania elementu do szablonu
  const addToScheduleMutation = useMutation({
    mutationFn: async (newItem: any) => {
      await apiRequest("POST", "/api/weekly-schedule", newItem);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/weekly-schedule"] });
      toast({ title: t("admin.template_added") || "Dodano do szablonu" });
    },
  });

  // Mutacja usuwania elementu z szablonu
  const deleteFromScheduleMutation = useMutation({
    mutationFn: async (id: number) => {
      await apiRequest("DELETE", `/api/weekly-schedule/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/weekly-schedule"] });
      toast({ title: t("admin.template_removed") || "Usunięto z szablonu" });
    },
  });

  const locale = i18n.language === "pl" ? pl : enUS;

  // Stan formularza generatora
  const [generateForm, setGenerateForm] = useState({
    startDate: format(new Date(), "yyyy-MM-dd"),
    endDate: format(addDays(new Date(), 30), "yyyy-MM-dd"),
  });

  // Stan formularza dodawania do szablonu
  const [newTemplateItem, setNewTemplateItem] = useState({
    dayOfWeek: "1", // Poniedziałek
    startTime: "16:00",
    durationMinutes: 60,
    price: 80,
    studentId: "none", // "none" oznacza wolny slot
  });

  const handleGenerate = () => {
    generateFromTemplate(generateForm, {
      onSuccess: (data: any) => {
        toast({
          title: t("booking.success"),
          description: data.message,
        });
        queryClient.invalidateQueries({ queryKey: ["/api/slots"] });
      },
      onError: (err) => {
        toast({
          variant: "destructive",
          title: "Błąd generatora",
          description: err.message,
        });
      },
    });
  };

  const handleAddToTemplate = () => {
    addToScheduleMutation.mutate({
      ...newTemplateItem,
      dayOfWeek: parseInt(newTemplateItem.dayOfWeek),
      studentId:
        newTemplateItem.studentId === "none"
          ? null
          : parseInt(newTemplateItem.studentId),
    });
  };

  const weekStart = startOfWeek(selectedDate, { weekStartsOn: 1 });
  const weekEnd = endOfWeek(selectedDate, { weekStartsOn: 1 });
  const weekDays = eachDayOfInterval({ start: weekStart, end: weekEnd });

  const dayMapping: Record<number, string> = {
    1: t("admin.days.1") || "Poniedziałek",
    2: t("admin.days.2") || "Wtorek",
    3: t("admin.days.3") || "Środa",
    4: t("admin.days.4") || "Czwartek",
    5: t("admin.days.5") || "Piątek",
    6: t("admin.days.6") || "Sobota",
    0: t("admin.days.0") || "Niedziela",
  };

  if (loadingSlots || loadingSchedule || loadingStudents)
    return (
      <div className="min-h-screen grid place-items-center">
        <Loader2 className="animate-spin w-10 h-10 text-primary" />
      </div>
    );

  return (
    <div className="min-h-screen bg-background pt-24 pb-12 px-4">
      <div className="max-w-[1600px] mx-auto space-y-8">
        <div className="flex flex-col md:flex-row justify-between items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold">{t("admin.title")}</h1>
            <p className="text-muted-foreground">{t("admin.subtitle")}</p>
          </div>
        </div>

        <Tabs defaultValue="calendar" className="w-full">
          <TabsList className="grid w-full md:w-[600px] grid-cols-3 mb-8">
            <TabsTrigger value="calendar">
              {t("admin.tab_calendar") || "Grafik"}
            </TabsTrigger>
            <TabsTrigger value="template">
              {t("admin.tab_template") || "Szablon"}
            </TabsTrigger>
            <TabsTrigger value="students">Baza Uczniów</TabsTrigger>
          </TabsList>

          {/* --- ZAKŁADKA 1: KALENDARZ (GRAFIK) --- */}
          <TabsContent value="calendar" className="space-y-6">
            <div className="flex flex-col md:flex-row justify-between items-center gap-4 bg-card p-4 rounded-xl border border-border shadow-sm">
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="icon"
                  onClick={() => setSelectedDate(subWeeks(selectedDate, 1))}
                >
                  <ChevronLeft className="w-5 h-5" />
                </Button>
                <span className="px-4 font-medium min-w-[180px] text-center capitalize text-lg">
                  {format(weekStart, "d MMM", { locale })} -{" "}
                  {format(weekEnd, "d MMM", { locale })}
                </span>
                <Button
                  variant="outline"
                  size="icon"
                  onClick={() => setSelectedDate(addWeeks(selectedDate, 1))}
                >
                  <ChevronRight className="w-5 h-5" />
                </Button>
              </div>

              <Dialog>
                <DialogTrigger asChild>
                  <Button className="gap-2 bg-primary text-primary-foreground hover:bg-primary/90 shadow-lg shadow-primary/20">
                    <Copy className="w-4 h-4" />{" "}
                    {t("admin.generate_from_template") || "Generuj z Szablonu"}
                  </Button>
                </DialogTrigger>
                <DialogContent className="sm:max-w-md bg-card border-border">
                  <DialogHeader>
                    <DialogTitle>{t("admin.generate_title")}</DialogTitle>
                    <DialogDescription>
                      {t("admin.generate_desc")}
                    </DialogDescription>
                  </DialogHeader>
                  <div className="grid gap-4 py-4">
                    <div className="grid grid-cols-2 gap-4">
                      <div className="space-y-2">
                        <Label>{t("admin.start_date")}</Label>
                        <Input
                          type="date"
                          value={generateForm.startDate}
                          onChange={(e) =>
                            setGenerateForm({
                              ...generateForm,
                              startDate: e.target.value,
                            })
                          }
                        />
                      </div>
                      <div className="space-y-2">
                        <Label>{t("admin.end_date")}</Label>
                        <Input
                          type="date"
                          value={generateForm.endDate}
                          onChange={(e) =>
                            setGenerateForm({
                              ...generateForm,
                              endDate: e.target.value,
                            })
                          }
                        />
                      </div>
                    </div>
                    <Button onClick={handleGenerate} disabled={isGenerating}>
                      {isGenerating && (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      )}
                      {t("admin.generate_submit")}
                    </Button>
                  </div>
                </DialogContent>
              </Dialog>
            </div>

            <div className="flex gap-4 overflow-x-auto pb-6 snap-x">
              {weekDays.map((day) => {
                const daySlots =
                  slots
                    ?.filter(
                      (s) =>
                        format(new Date(s.startTime), "yyyy-MM-dd") ===
                        format(day, "yyyy-MM-dd")
                    )
                    .sort(
                      (a, b) =>
                        new Date(a.startTime).getTime() -
                        new Date(b.startTime).getTime()
                    ) || [];

                return (
                  <div
                    key={day.toString()}
                    className="min-w-[280px] flex-shrink-0 snap-start"
                  >
                    <div className="text-center p-3 mb-3 bg-muted/30 rounded-xl border border-border sticky left-0 backdrop-blur-sm">
                      <div className="text-sm font-medium text-muted-foreground capitalize">
                        {format(day, "EEEE", { locale })}
                      </div>
                      <div className="text-xl font-bold text-foreground">
                        {format(day, "d MMM", { locale })}
                      </div>
                    </div>

                    <div className="space-y-3">
                      {daySlots.map((slot: any) => (
                        <Card
                          key={slot.id}
                          className={`p-3 relative group transition-all shadow-sm border-l-4 ${
                            slot.isBooked
                              ? slot.isPaid
                                ? "border-l-green-500 bg-card"
                                : "border-l-orange-500 bg-card"
                              : "border-l-primary/30 bg-muted/10 border-dashed border-y-0 border-r-0"
                          }`}
                        >
                          <div className="flex justify-between items-start mb-2">
                            <span className="text-sm font-bold font-mono px-2 py-1 bg-muted rounded">
                              {format(new Date(slot.startTime), "HH:mm")}
                            </span>
                            <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity bg-background/90 rounded-lg shadow-sm p-1 absolute top-2 right-2">
                              {slot.isBooked && (
                                <button
                                  onClick={() =>
                                    updateSlot({
                                      id: slot.id,
                                      updates: { isPaid: !slot.isPaid },
                                    })
                                  }
                                  title={
                                    slot.isPaid
                                      ? t("dashboard.unpaid")
                                      : t("dashboard.paid")
                                  }
                                  className={`${
                                    slot.isPaid
                                      ? "text-green-500"
                                      : "text-gray-400"
                                  } hover:scale-110 transition-transform p-1`}
                                >
                                  <CheckCircle size={16} />
                                </button>
                              )}
                              {slot.isBooked && (
                                <button
                                  onClick={() =>
                                    updateSlot({
                                      id: slot.id,
                                      updates: {
                                        isBooked: false,
                                        studentId: null,
                                        isPaid: false,
                                      },
                                    })
                                  }
                                  title="Anuluj rezerwację"
                                  className="text-orange-500 hover:text-orange-400 p-1"
                                >
                                  <Ban size={16} />
                                </button>
                              )}

                              <button
                                onClick={() => {
                                  if (confirm(t("admin.delete_confirm")))
                                    deleteSlot(slot.id);
                                }}
                                className="text-destructive hover:text-red-400 p-1"
                                title="Usuń slot"
                              >
                                <Trash2 size={16} />
                              </button>
                            </div>
                          </div>

                          {slot.isBooked ? (
                            <div className="text-xs space-y-2 mt-2">
                              <div className="font-medium text-foreground flex items-center gap-2 border-b border-border/50 pb-2">
                                <User className="w-3.5 h-3.5 text-primary" />
                                <span className="truncate text-sm font-bold">
                                  {slot.student?.name || t("admin.booked")}
                                </span>
                              </div>

                              {slot.student && (
                                <div className="space-y-1.5 pt-1 text-muted-foreground">
                                  {slot.student.phone && (
                                    <div className="flex items-center gap-2">
                                      <Phone className="w-3 h-3 flex-shrink-0" />
                                      <span>{slot.student.phone}</span>
                                    </div>
                                  )}
                                  {slot.price > 0 && (
                                    <div className="flex items-center gap-2">
                                      <span className="font-mono text-foreground">
                                        {slot.price} PLN
                                      </span>
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                          ) : (
                            <div className="text-xs text-muted-foreground/70 font-medium py-2 text-center mt-2 flex items-center justify-center gap-1">
                              <CheckCircle className="w-3 h-3" />{" "}
                              {t("admin.available")}
                            </div>
                          )}
                        </Card>
                      ))}
                      {daySlots.length === 0 && (
                        <div className="text-center py-12 text-sm text-muted-foreground border-2 border-dashed border-border/50 rounded-xl opacity-50">
                          {t("admin.no_slots")}
                        </div>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </TabsContent>

          {/* --- ZAKŁADKA 2: SZABLON (WEEKLY SCHEDULE) --- */}
          <TabsContent value="template" className="space-y-8">
            <Card className="border-secondary/20 shadow-md">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <CalendarIcon className="w-5 h-5 text-primary" />
                  {t("admin.template_title") || "Edytor Szablonu"}
                </CardTitle>
                <p className="text-sm text-muted-foreground">
                  {t("admin.template_desc")}
                </p>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-6 gap-4 items-end mb-8 bg-muted/30 p-4 rounded-xl border border-border">
                  <div className="space-y-2 md:col-span-1">
                    <Label>{t("admin.day")}</Label>
                    <Select
                      value={newTemplateItem.dayOfWeek}
                      onValueChange={(val) =>
                        setNewTemplateItem({
                          ...newTemplateItem,
                          dayOfWeek: val,
                        })
                      }
                    >
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="1">{dayMapping[1]}</SelectItem>
                        <SelectItem value="2">{dayMapping[2]}</SelectItem>
                        <SelectItem value="3">{dayMapping[3]}</SelectItem>
                        <SelectItem value="4">{dayMapping[4]}</SelectItem>
                        <SelectItem value="5">{dayMapping[5]}</SelectItem>
                        <SelectItem value="6">{dayMapping[6]}</SelectItem>
                        <SelectItem value="0">{dayMapping[0]}</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2 md:col-span-1">
                    <Label>{t("admin.hour")}</Label>
                    <Input
                      type="time"
                      value={newTemplateItem.startTime}
                      onChange={(e) =>
                        setNewTemplateItem({
                          ...newTemplateItem,
                          startTime: e.target.value,
                        })
                      }
                    />
                  </div>
                  <div className="space-y-2 md:col-span-1">
                    <Label>{t("admin.time")}</Label>
                    <Input
                      type="number"
                      value={newTemplateItem.durationMinutes}
                      onChange={(e) =>
                        setNewTemplateItem({
                          ...newTemplateItem,
                          durationMinutes: parseInt(e.target.value),
                        })
                      }
                    />
                  </div>
                  <div className="space-y-2 md:col-span-1">
                    <Label>{t("admin.price")}</Label>
                    <Input
                      type="number"
                      value={newTemplateItem.price}
                      onChange={(e) =>
                        setNewTemplateItem({
                          ...newTemplateItem,
                          price: parseInt(e.target.value),
                        })
                      }
                    />
                  </div>
                  <div className="space-y-2 md:col-span-1">
                    <Label>{t("admin.student")}</Label>
                    <Select
                      value={newTemplateItem.studentId}
                      onValueChange={(val) =>
                        setNewTemplateItem({
                          ...newTemplateItem,
                          studentId: val,
                        })
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Wybierz..." />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="none">
                          {t("admin.student_none") || "-- Wolny termin --"}
                        </SelectItem>
                        {students
                          ?.filter((s) => s.role === "student")
                          .map((s) => (
                            <SelectItem key={s.id} value={s.id.toString()}>
                              {s.name} ({s.username})
                            </SelectItem>
                          ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="md:col-span-1">
                    <Button
                      onClick={handleAddToTemplate}
                      className="w-full bg-green-600 hover:bg-green-700 text-white"
                      disabled={addToScheduleMutation.isPending}
                    >
                      <Plus className="w-4 h-4 mr-2" />{" "}
                      {t("admin.add_btn") || "Dodaj"}
                    </Button>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-6 gap-4">
                  {[1, 2, 3, 4, 5, 6].map((day) => {
                    const dayItems =
                      weeklySchedule?.filter((i) => i.dayOfWeek === day) || [];

                    return (
                      <Card key={day} className="bg-card">
                        <CardHeader className="py-3 px-4 border-b border-border bg-muted/20">
                          <CardTitle className="text-base capitalize text-center">
                            {dayMapping[day]}
                          </CardTitle>
                        </CardHeader>
                        <CardContent className="p-2 space-y-2">
                          {dayItems.length === 0 ? (
                            <p className="text-xs text-center text-muted-foreground py-4">
                              {t("admin.empty") || "Pusto"}
                            </p>
                          ) : (
                            dayItems.map((item) => (
                              <div
                                key={item.id}
                                className="flex items-center justify-between p-2 rounded-lg border border-border bg-background text-xs group"
                              >
                                <div>
                                  <div className="font-bold text-primary">
                                    {item.startTime} ({item.durationMinutes}m)
                                  </div>
                                  <div className="text-muted-foreground truncate max-w-[100px]">
                                    {item.student
                                      ? item.student.name
                                      : t("admin.available") || "Wolny"}
                                  </div>
                                  <div className="font-mono text-[10px] opacity-70">
                                    {item.price} PLN
                                  </div>
                                </div>
                                <Button
                                  variant="ghost"
                                  size="icon"
                                  className="h-6 w-6 text-destructive opacity-0 group-hover:opacity-100 transition-opacity"
                                  onClick={() =>
                                    deleteFromScheduleMutation.mutate(item.id)
                                  }
                                >
                                  <Trash2 className="w-3 h-3" />
                                </Button>
                              </div>
                            ))
                          )}
                        </CardContent>
                      </Card>
                    );
                  })}
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* --- ZAKŁADKA 3: BAZA UCZNIÓW --- */}
          <TabsContent value="students" className="space-y-6">
            <Card className="border-secondary/20 shadow-md h-[70vh] flex flex-col">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Users className="w-5 h-5 text-primary" />
                  Baza Uczniów
                </CardTitle>
                <p className="text-sm text-muted-foreground">
                  Przeglądaj zarejestrowanych uczniów.
                </p>
              </CardHeader>
              <CardContent className="flex-1 overflow-auto">
                {students?.filter((s) => s.role === "student").length === 0 ? (
                  <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
                    <Users className="w-12 h-12 mb-4 opacity-20" />
                    <p>Brak zarejestrowanych uczniów.</p>
                  </div>
                ) : (
                  <div className="relative w-full overflow-auto">
                    <table className="w-full caption-bottom text-sm text-left">
                      <thead className="[&_tr]:border-b">
                        <tr className="border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted">
                          <th className="h-12 px-4 text-left align-middle font-medium text-muted-foreground">
                            ID
                          </th>
                          <th className="h-12 px-4 text-left align-middle font-medium text-muted-foreground">
                            Imię i Nazwisko
                          </th>
                          <th className="h-12 px-4 text-left align-middle font-medium text-muted-foreground">
                            Login
                          </th>
                          <th className="h-12 px-4 text-left align-middle font-medium text-muted-foreground">
                            Email
                          </th>
                          <th className="h-12 px-4 text-left align-middle font-medium text-muted-foreground">
                            Telefon
                          </th>
                          <th className="h-12 px-4 text-left align-middle font-medium text-muted-foreground">
                            Adres
                          </th>
                        </tr>
                      </thead>
                      <tbody className="[&_tr:last-child]:border-0">
                        {students
                          ?.filter((s) => s.role === "student")
                          .map((student) => (
                            <tr
                              key={student.id}
                              className="border-b transition-colors hover:bg-muted/50"
                            >
                              <td className="p-4 align-middle font-mono text-xs">
                                {student.id}
                              </td>
                              <td className="p-4 align-middle font-medium">
                                {student.name}
                              </td>
                              <td className="p-4 align-middle">
                                {student.username}
                              </td>
                              <td className="p-4 align-middle text-muted-foreground">
                                {student.email || "-"}
                              </td>
                              <td className="p-4 align-middle">
                                {student.phone || "-"}
                              </td>
                              <td className="p-4 align-middle">
                                {student.address || "-"}
                              </td>
                            </tr>
                          ))}
                      </tbody>
                    </table>
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}
---------------------------------------
import { db, pool } from "./db";
import {
  users,
  slots,
  waitlist,
  weeklySchedule,
  type User,
  type InsertUser,
  type Slot,
  type InsertSlot,
  type Waitlist,
  type InsertWaitlist,
  type WeeklySchedule,
  type InsertWeeklySchedule,
} from "@shared/schema";
import { eq, and, gte, lte, asc } from "drizzle-orm";
import session from "express-session";
import connectPg from "connect-pg-simple";

const PostgresSessionStore = connectPg(session);

export interface IStorage {
  sessionStore: session.Store;

  // User
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  // NOWA METODA
  getAllUsers(): Promise<User[]>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, user: Partial<InsertUser>): Promise<User>;

  // Slots
  getSlots(
    start?: Date,
    end?: Date
  ): Promise<(Slot & { student?: User | null })[]>;
  getSlot(id: number): Promise<Slot | undefined>;
  createSlot(slot: InsertSlot): Promise<Slot>;
  updateSlot(id: number, updates: Partial<InsertSlot>): Promise<Slot>;
  deleteSlot(id: number): Promise<void>;

  // Waitlist
  addToWaitlist(entry: InsertWaitlist): Promise<Waitlist>;
  getWaitlist(date: Date): Promise<Waitlist[]>;

  // Weekly Schedule
  getWeeklySchedule(): Promise<(WeeklySchedule & { student?: User | null })[]>;
  createWeeklyScheduleItem(item: InsertWeeklySchedule): Promise<WeeklySchedule>;
  deleteWeeklyScheduleItem(id: number): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  sessionStore: session.Store;

  constructor() {
    this.sessionStore = new PostgresSessionStore({
      pool,
      createTableIfMissing: true,
    });
  }

  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.username, username));
    return user;
  }

  // NOWA METODA: Implementacja
  async getAllUsers(): Promise<User[]> {
    return await db.select().from(users).orderBy(asc(users.username));
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }

  async updateUser(
    id: number,
    partialUser: Partial<InsertUser>
  ): Promise<User> {
    const [user] = await db
      .update(users)
      .set(partialUser)
      .where(eq(users.id, id))
      .returning();

    if (!user) {
      throw new Error("User not found");
    }
    return user;
  }

  async getSlots(
    start?: Date,
    end?: Date
  ): Promise<(Slot & { student?: User | null })[]> {
    let query = db
      .select({
        slot: slots,
        student: users,
      })
      .from(slots)
      .leftJoin(users, eq(slots.studentId, users.id))
      .orderBy(asc(slots.startTime));

    if (start && end) {
      // @ts-ignore - Drizzle query builder typing workaround
      query = query.where(
        and(gte(slots.startTime, start), lte(slots.startTime, end))
      );
    }

    const results = await query;

    return results.map(({ slot, student }) => ({
      ...slot,
      student: student || null,
    }));
  }

  async getSlot(id: number): Promise<Slot | undefined> {
    const [slot] = await db.select().from(slots).where(eq(slots.id, id));
    return slot;
  }

  async createSlot(slot: InsertSlot): Promise<Slot> {
    const [newSlot] = await db.insert(slots).values(slot).returning();
    return newSlot;
  }

  async updateSlot(id: number, updates: Partial<InsertSlot>): Promise<Slot> {
    const [updated] = await db
      .update(slots)
      .set(updates)
      .where(eq(slots.id, id))
      .returning();
    return updated;
  }

  async deleteSlot(id: number): Promise<void> {
    await db.delete(slots).where(eq(slots.id, id));
  }

  async addToWaitlist(entry: InsertWaitlist): Promise<Waitlist> {
    const [item] = await db.insert(waitlist).values(entry).returning();
    return item;
  }

  async getWaitlist(date: Date): Promise<Waitlist[]> {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);

    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    return await db
      .select()
      .from(waitlist)
      .where(and(gte(waitlist.date, startOfDay), lte(waitlist.date, endOfDay)));
  }

  async getWeeklySchedule(): Promise<
    (WeeklySchedule & { student?: User | null })[]
  > {
    const results = await db
      .select({
        schedule: weeklySchedule,
        student: users,
      })
      .from(weeklySchedule)
      .leftJoin(users, eq(weeklySchedule.studentId, users.id))
      .orderBy(asc(weeklySchedule.dayOfWeek), asc(weeklySchedule.startTime));

    return results.map(({ schedule, student }) => ({
      ...schedule,
      student: student || null,
    }));
  }

  async createWeeklyScheduleItem(
    item: InsertWeeklySchedule
  ): Promise<WeeklySchedule> {
    const [newItem] = await db.insert(weeklySchedule).values(item).returning();
    return newItem;
  }

  async deleteWeeklyScheduleItem(id: number): Promise<void> {
    await db.delete(weeklySchedule).where(eq(weeklySchedule.id, id));
  }
}

export const storage = new DatabaseStorage();
-----------------------------------
import { useState } from "react";
import { useSlots, useBookSlot, useCancelSlot } from "@/hooks/use-slots";
import { useUser } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  format,
  startOfWeek,
  addWeeks,
  subWeeks,
  isBefore,
  addHours,
} from "date-fns";
import { pl, enUS } from "date-fns/locale";
import { Loader2, ChevronLeft, ChevronRight } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription, // POPRAWKA: Dodano import
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { useTranslation } from "react-i18next";

export default function BookingPage() {
  const { t, i18n } = useTranslation();
  const [currentWeek, setCurrentWeek] = useState(new Date());
  const [selectedSlot, setSelectedSlot] = useState<any>(null);
  const [bookingTopic, setBookingTopic] = useState("");

  const { data: user } = useUser();
  const { data: slots, isLoading } = useSlots();
  const { mutate: bookSlot, isPending: isBooking } = useBookSlot();
  const { mutate: cancelSlot } = useCancelSlot();
  const { toast } = useToast();

  const locale = i18n.language === "pl" ? pl : enUS;

  const handleBook = () => {
    if (!selectedSlot) return;

    bookSlot(selectedSlot.id, {
      onSuccess: () => {
        toast({
          title: t("booking.success"),
          description: t("booking.success_desc"),
        });
        setSelectedSlot(null);
        setBookingTopic("");
      },
    });
  };

  const handleCancel = (slot: any) => {
    const slotTime = new Date(slot.startTime);
    // Guard 24h na froncie
    if (isBefore(slotTime, addHours(new Date(), 24))) {
      toast({
        variant: "destructive",
        title: t("booking.cancel_error_title"),
        description: t("booking.cancel_error_desc"),
      });
      return;
    }

    if (confirm(t("booking.cancel_confirm"))) {
      cancelSlot(slot.id);
    }
  };

  const startOfCurrentWeek = startOfWeek(currentWeek, { weekStartsOn: 1 });

  const weekDates = Array.from({ length: 7 }).map((_, i) => {
    const d = new Date(startOfCurrentWeek);
    d.setDate(d.getDate() + i);
    return d;
  });

  if (isLoading)
    return (
      <div className="min-h-screen grid place-items-center">
        <Loader2 className="animate-spin w-10 h-10 text-primary" />
      </div>
    );

  return (
    <div className="min-h-screen bg-background pt-24 pb-12 px-4">
      <div className="max-w-7xl mx-auto space-y-8">
        <div className="flex flex-col md:flex-row justify-between items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold">{t("booking.title")}</h1>
            <p className="text-muted-foreground">{t("booking.subtitle")}</p>
          </div>
          <div className="flex items-center gap-2 bg-card p-1 rounded-xl border border-border">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setCurrentWeek(subWeeks(currentWeek, 1))}
            >
              <ChevronLeft className="w-5 h-5" />
            </Button>
            <span className="px-4 font-medium min-w-[140px] text-center capitalize">
              {format(startOfCurrentWeek, "MMM d", { locale })} -{" "}
              {format(weekDates[6], "MMM d", { locale })}
            </span>
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setCurrentWeek(addWeeks(currentWeek, 1))}
            >
              <ChevronRight className="w-5 h-5" />
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-7 gap-4">
          {weekDates.map((date) => {
            const dateStr = format(date, "yyyy-MM-dd");
            const isToday = dateStr === format(new Date(), "yyyy-MM-dd");
            const dailySlots =
              slots
                ?.filter(
                  (s) => format(new Date(s.startTime), "yyyy-MM-dd") === dateStr
                )
                .sort(
                  (a, b) =>
                    new Date(a.startTime).getTime() -
                    new Date(b.startTime).getTime()
                ) || [];

            return (
              <div
                key={dateStr}
                className={`space-y-3 ${
                  isToday ? "bg-primary/5 rounded-2xl p-2 -m-2" : ""
                }`}
              >
                <div className="text-center mb-4">
                  <div className="text-sm text-muted-foreground uppercase font-bold">
                    {format(date, "EEE", { locale })}
                  </div>
                  <div
                    className={`text-2xl font-bold ${
                      isToday ? "text-primary" : ""
                    }`}
                  >
                    {format(date, "d")}
                  </div>
                </div>

                {dailySlots.length === 0 ? (
                  <div className="text-center py-4 text-sm text-muted-foreground/50">
                    {t("booking.no_slots")}
                  </div>
                ) : (
                  dailySlots.map((slot) => {
                    const isMyBooking = slot.studentId === user?.id;
                    const isBookedOther = slot.isBooked && !isMyBooking;

                    if (isBookedOther)
                      return (
                        <div
                          key={slot.id}
                          className="p-3 rounded-xl bg-muted/50 border border-border opacity-50 cursor-not-allowed text-center"
                        >
                          <span className="text-sm font-medium line-through decoration-muted-foreground/50 text-muted-foreground">
                            {format(new Date(slot.startTime), "HH:mm")}
                          </span>
                        </div>
                      );

                    if (isMyBooking)
                      return (
                        <button
                          key={slot.id}
                          onClick={() => handleCancel(slot)}
                          className="w-full p-3 rounded-xl bg-orange-500 text-white shadow-lg shadow-orange-500/20 hover:bg-orange-600 transition-all flex flex-col items-center group relative overflow-hidden"
                        >
                          <span className="text-sm font-bold relative z-10">
                            {format(new Date(slot.startTime), "HH:mm")}
                          </span>
                          <span className="text-[10px] opacity-90 relative z-10">
                            {t("booking.your_booking")}
                          </span>
                          <div className="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300" />
                        </button>
                      );

                    return (
                      <button
                        key={slot.id}
                        onClick={() => setSelectedSlot(slot)}
                        className="w-full p-3 rounded-xl bg-card border border-primary/20 hover:border-primary hover:bg-primary/5 transition-all group"
                      >
                        <span className="text-sm font-bold text-primary group-hover:scale-110 block transition-transform">
                          {format(new Date(slot.startTime), "HH:mm")}
                        </span>
                      </button>
                    );
                  })
                )}
              </div>
            );
          })}
        </div>
      </div>

      <Dialog
        open={!!selectedSlot}
        onOpenChange={(open) => !open && setSelectedSlot(null)}
      >
        <DialogContent className="bg-card border-border sm:max-w-md">
          <DialogHeader>
            <DialogTitle>{t("booking.confirm_title")}</DialogTitle>
            {/* POPRAWKA: Dodano DialogDescription */}
            <DialogDescription>
              {t("booking.confirm_desc") ||
                "Please verify the details below before confirming."}
            </DialogDescription>
          </DialogHeader>
          <div className="py-4 space-y-4">
            <div className="bg-muted p-4 rounded-xl border border-border">
              <p className="text-sm text-muted-foreground">
                {t("booking.time")}
              </p>
              <p className="text-xl font-bold capitalize">
                {selectedSlot &&
                  format(
                    new Date(selectedSlot.startTime),
                    "EEEE, d MMMM, HH:mm",
                    { locale }
                  )}
              </p>
            </div>

            <div className="space-y-2">
              <Label>{t("booking.topic_label")}</Label>
              <Input
                placeholder={t("booking.topic_placeholder")}
                value={bookingTopic}
                onChange={(e) => setBookingTopic(e.target.value)}
              />
            </div>

            <div className="flex justify-end gap-3 pt-4">
              <Button variant="ghost" onClick={() => setSelectedSlot(null)}>
                {t("booking.cancel_btn")}
              </Button>
              <Button onClick={handleBook} disabled={isBooking}>
                {isBooking && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                {t("booking.confirm_btn")}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
--------------------------------
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { type User, insertUserSchema } from "@shared/schema";
import { useLocation } from "wouter";
import { z } from "zod";
import { useToast } from "@/hooks/use-toast";

export function useUser() {
  return useQuery<User | null>({
    queryKey: ["/api/user"],
    queryFn: async () => {
      const res = await fetch("/api/user");
      if (res.status === 401) return null;
      if (!res.ok) throw new Error("Failed to fetch user");
      return await res.json();
    },
    retry: false,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useLogin() {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (credentials: { username: string; password: string }) => {
      const res = await fetch("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });

      if (!res.ok) {
        throw new Error("Invalid credentials");
      }
      return (await res.json()) as User;
    },
    onSuccess: (user) => {
      queryClient.setQueryData(["/api/user"], user);
      setLocation(user.role === "admin" ? "/admin" : "/dashboard");
      toast({
        title: "Welcome back!",
        description: `Logged in as ${user.username}`,
      });
    },
    onError: (error) => {
      toast({
        title: "Login failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

export function useRegister() {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: z.infer<typeof insertUserSchema>) => {
      const res = await fetch("/api/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(errorText || "Registration failed");
      }
      return (await res.json()) as User;
    },
    onSuccess: (user) => {
      queryClient.setQueryData(["/api/user"], user);
      setLocation(user.role === "admin" ? "/admin" : "/dashboard");
      toast({ title: "Welcome!", description: "Account created successfully" });
    },
    onError: (error) => {
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

export function useLogout() {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/logout", {
        method: "POST",
      });
      if (!res.ok) throw new Error("Logout failed");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
      setLocation("/");
      toast({ title: "Logged out", description: "See you next time!" });
    },
  });
}

// NOWY HOOK: Zmiana hasła
export function useChangePassword() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: {
      currentPassword: string;
      newPassword: string;
    }) => {
      const res = await fetch("/api/change-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Failed to change password");
      }
      return await res.json();
    },
    onSuccess: () => {
      toast({
        title: "Success",
        description: "Password changed successfully",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}
-----------------------------------
import type { Express } from "express";
import type { Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";
import {
  insertSlotSchema,
  generateSlotsSchema,
  insertWaitlistSchema,
  insertWeeklyScheduleSchema,
  generateFromTemplateSchema,
  insertUserSchema,
  type User,
} from "@shared/schema";
import { z } from "zod";
import {
  addDays,
  setHours,
  setMinutes,
  parseISO,
  differenceInHours,
  format,
  getYear,
  getDay,
  addMinutes,
  areIntervalsOverlapping,
  differenceInMinutes,
} from "date-fns";
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

// --- POMOCNIKI CZASU (STREFA PL) ---

// Zwraca godzinę i minutę w czasie warszawskim dla danej daty UTC
function getWarsawHourMinute(date: Date) {
  // Konwertujemy datę na string w strefie Europe/Warsaw
  const plTimeStr = date.toLocaleString("en-US", {
    timeZone: "Europe/Warsaw",
    hour12: false,
    hour: "2-digit",
    minute: "2-digit",
  });
  const [h, m] = plTimeStr.split(":").map(Number);
  // Obsługa przypadku 24:00 (rzadkie, ale możliwe w niektórych implementacjach)
  return { h: h === 24 ? 0 : h, m };
}

// Sprawdza czy data to konkretny dzień tygodnia i godzina (wg czasu PL)
function isWarsawTime(
  date: Date,
  targetDay: number,
  targetH: number,
  targetM: number
) {
  const day = getDay(date); // getDay zwraca dzień lokalny, ale dla bezpieczeństwa sprawdzamy string
  const plDateStr = date.toLocaleString("en-US", {
    timeZone: "Europe/Warsaw",
    weekday: "short",
  });
  // Mapowanie dni: Sun=0, Mon=1...
  const daysMap: Record<string, number> = {
    Sun: 0,
    Mon: 1,
    Tue: 2,
    Wed: 3,
    Thu: 4,
    Fri: 5,
    Sat: 6,
  };
  const currentDay = daysMap[plDateStr.split(",")[0]] ?? day;

  if (currentDay !== targetDay) return false;

  const { h, m } = getWarsawHourMinute(date);
  return h === targetH && Math.abs(m - targetM) < 2; // Tolerancja 1 minuty
}

// Cache dla świąt
const holidayCache = new Map<number, Set<string>>();

async function getPublicHolidays(year: number): Promise<Set<string>> {
  if (holidayCache.has(year)) {
    return holidayCache.get(year)!;
  }

  try {
    console.log(`Fetching public holidays for year ${year}...`);
    const response = await fetch(
      `https://date.nager.at/api/v3/PublicHolidays/${year}/PL`
    );
    if (!response.ok) return new Set();
    const data = (await response.json()) as { date: string }[];
    const holidays = new Set(data.map((h) => h.date));
    holidayCache.set(year, holidays);
    return holidays;
  } catch (error) {
    console.error("Failed to fetch holidays:", error);
    return new Set();
  }
}

// --- STAŁY GRAFIK UCZNIÓW ---
const FIXED_STUDENT_SCHEDULE = [
  // Poniedziałek (1)
  { day: 1, start: "11:00", duration: 60, name: "Masia S." },
  { day: 1, start: "13:30", duration: 60, name: "Natasza Z." },
  { day: 1, start: "14:50", duration: 60, name: "Marcel M." },
  { day: 1, start: "16:30", duration: 60, name: "Martyna S." },
  { day: 1, start: "17:50", duration: 60, name: "Ksawery D." },
  { day: 1, start: "19:00", duration: 60, name: "Filip B." },

  // Wtorek (2)
  { day: 2, start: "12:00", duration: 120, name: "Julka B." },
  { day: 2, start: "14:30", duration: 60, name: "Oskar Z." },
  { day: 2, start: "16:20", duration: 60, name: "Wiktor B." },
  { day: 2, start: "18:00", duration: 60, name: "Julka S." },
  { day: 2, start: "19:00", duration: 60, name: "Tobiasz S." },

  // Środa (3)
  { day: 3, start: "12:00", duration: 60, name: "Franek L." },
  { day: 3, start: "14:40", duration: 60, name: "Mateusz M." },
  { day: 3, start: "16:15", duration: 90, name: "Olek P." },
  { day: 3, start: "18:00", duration: 60, name: "Olek Ś." },

  // Czwartek (4)
  { day: 4, start: "12:10", duration: 60, name: "Ola S." },
  { day: 4, start: "14:50", duration: 60, name: "Michał G." },
  { day: 4, start: "16:30", duration: 60, name: "Paweł S." },
  { day: 4, start: "17:45", duration: 60, name: "Małgosia K." },
  { day: 4, start: "19:00", duration: 60, name: "Adam L." },

  // Piątek (5)
  { day: 5, start: "13:30", duration: 60, name: "Oskar Z." },
  { day: 5, start: "14:30", duration: 60, name: "Pola M." },
  { day: 5, start: "16:30", duration: 60, name: "Natalia B." },
  { day: 5, start: "18:00", duration: 120, name: "Kacper M." },

  // Sobota (6)
  { day: 6, start: "08:45", duration: 90, name: "Michał W." },
  { day: 6, start: "10:30", duration: 120, name: "Oliwia P." },
  { day: 6, start: "13:00", duration: 60, name: "Kacper D." },
  { day: 6, start: "14:30", duration: 60, name: "Janek P." },
  { day: 6, start: "15:30", duration: 60, name: "Oskar N." },
  { day: 6, start: "17:00", duration: 90, name: "Antek Ż." },
];

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  setupAuth(app);

  app.get("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    res.header("Cache-Control", "no-store, max-age=0");
    const users = await storage.getAllUsers();
    res.json(users);
  });

  app.post("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const userData = insertUserSchema.parse(req.body);
      const existingUser = await storage.getUserByUsername(userData.username);
      if (existingUser) {
        return res.status(409).json({ message: "Użytkownik już istnieje." });
      }
      const hashedPassword = await hashPassword(userData.password);
      const newUser = await storage.createUser({
        ...userData,
        password: hashedPassword,
        role: "student",
      });
      res.status(201).json(newUser);
    } catch (err) {
      if (err instanceof z.ZodError) {
        res.status(400).json({ message: err.issues[0].message });
      } else {
        res.status(500).json({ message: "Internal server error" });
      }
    }
  });

  app.delete("/api/users/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteUser(id);
    res.sendStatus(204);
  });

  // --- SLOTY ---

  app.get("/api/slots", async (req, res) => {
    try {
      const start = req.query.start
        ? new Date(req.query.start as string)
        : undefined;
      const end = req.query.end ? new Date(req.query.end as string) : undefined;

      const slots = await storage.getSlots(start, end);
      if (slots.length === 0) return res.json(slots);

      const years = new Set(slots.map((s) => getYear(s.startTime)));
      const holidaySets = await Promise.all(
        Array.from(years).map((y) => getPublicHolidays(y))
      );
      const allHolidays = new Set<string>();
      holidaySets.forEach((set) =>
        set.forEach((date) => allHolidays.add(date))
      );

      const filteredSlots = slots.filter((slot) => {
        if (slot.isBooked) return true; // Zarezerwowane zawsze pokazujemy

        const dateStr = format(slot.startTime, "yyyy-MM-dd");
        // Ukryj wolne sloty w święta
        if (allHolidays.has(dateStr)) return false;

        // --- FILTR KOLIZJI (Z UWZGLĘDNIENIEM STREFY CZASOWEJ) ---
        const dayOfWeek = getDay(slot.startTime); // 0-6
        const dailyFixed = FIXED_STUDENT_SCHEDULE.filter(
          (l) => l.day === dayOfWeek
        );

        // Pobieramy godzinę startu slotu w czasie PL
        const slotPl = getWarsawHourMinute(slot.startTime);
        const slotStartMinutes = slotPl.h * 60 + slotPl.m;
        // Obliczamy długość slotu w minutach
        const duration = differenceInMinutes(slot.endTime, slot.startTime);
        const slotEndMinutes = slotStartMinutes + duration;

        const hasCollision = dailyFixed.some((fixedLesson) => {
          const [fh, fm] = fixedLesson.start.split(":").map(Number);
          const fixedStartMinutes = fh * 60 + fm;
          const fixedEndMinutes = fixedStartMinutes + fixedLesson.duration;

          // Sprawdzamy nakładanie się przedziałów (czas PL vs czas PL)
          return (
            slotStartMinutes < fixedEndMinutes &&
            slotEndMinutes > fixedStartMinutes
          );
        });

        if (hasCollision) return false;

        return true;
      });

      res.json(filteredSlots);
    } catch (err) {
      res.status(500).json({ message: "Failed to fetch slots" });
    }
  });

  app.post("/api/slots", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertSlotSchema.parse(req.body);
      const slot = await storage.createSlot(input);
      res.status(201).json(slot);
    } catch (err) {
      res.status(400).json({ message: "Error creating slot" });
    }
  });

  app.patch("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const id = parseInt(req.params.id);
      const input = insertSlotSchema.partial().parse(req.body);
      const updated = await storage.updateSlot(id, input);
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Failed to update slot" });
    }
  });

  app.delete("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteSlot(id);
    res.sendStatus(204);
  });

  app.get("/api/weekly-schedule", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const schedule = await storage.getWeeklySchedule();
    res.json(schedule);
  });

  app.post("/api/weekly-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertWeeklyScheduleSchema.parse(req.body);
      const item = await storage.createWeeklyScheduleItem(input);
      res.status(201).json(item);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/weekly-schedule/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteWeeklyScheduleItem(id);
    res.sendStatus(204);
  });

  // --- GENERATORY ---

  // 1. ZWYKŁY GENERATOR (Tworzy wolne sloty, uwzględnia strefę czasową PL przy kolizjach)
  app.post("/api/slots/generate", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const { startDate, endDate, startTime, endTime, duration } =
        generateSlotsSchema.parse(req.body);

      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const startYear = getYear(start);
      const holidays = await getPublicHolidays(startYear);
      if (getYear(end) !== startYear) {
        const h2 = await getPublicHolidays(getYear(end));
        h2.forEach((h) => holidays.add(h));
      }

      const existingSlots = await storage.getSlots(start, addDays(end, 1));
      const existingTimestamps = new Set(
        existingSlots.map((s) => s.startTime.getTime())
      );

      const [startHour, startMinute] = startTime.split(":").map(Number);
      const [endHour, endMinute] = endTime.split(":").map(Number);

      let currentDay = start;
      let count = 0;

      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");
        const dayOfWeek = getDay(currentDay);

        if (holidays.has(dateStr)) {
          currentDay = addDays(currentDay, 1);
          continue;
        }

        if (dayOfWeek !== 0) {
          const fixedLessons = FIXED_STUDENT_SCHEDULE.filter(
            (l) => l.day === dayOfWeek
          );

          let daySlotStart = setMinutes(
            setHours(currentDay, startHour),
            startMinute
          );
          const daySlotEnd = setMinutes(
            setHours(currentDay, endHour),
            endMinute
          );

          while (daySlotStart < daySlotEnd) {
            const slotEnd = addMinutes(daySlotStart, duration);
            if (slotEnd > daySlotEnd) break;

            // Sprawdzenie kolizji w czasie PL
            const { h: slotH, m: slotM } = getWarsawHourMinute(daySlotStart);
            const slotStartMin = slotH * 60 + slotM;
            const slotEndMin = slotStartMin + duration;

            const isCollision = fixedLessons.some((lesson) => {
              const [lh, lm] = lesson.start.split(":").map(Number);
              const lessonStartMin = lh * 60 + lm;
              const lessonEndMin = lessonStartMin + lesson.duration;

              return slotStartMin < lessonEndMin && slotEndMin > lessonStartMin;
            });

            if (
              !isCollision &&
              !existingTimestamps.has(daySlotStart.getTime())
            ) {
              await storage.createSlot({
                startTime: daySlotStart,
                endTime: slotEnd,
                isBooked: false,
                isPaid: false,
              });
              count++;
            }
            daySlotStart = slotEnd;
          }
        }
        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({ count });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate slots" });
    }
  });

  // 2. GENERATOR ZE SZABLONU (NAPRAWIA I TWORZY - z obsługą strefy czasowej PL)
  app.post("/api/slots/generate-from-template", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const { startDate, endDate } = generateFromTemplateSchema.parse(req.body);
      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const allUsers = await storage.getAllUsers();

      const startYear = getYear(start);
      const holidays = await getPublicHolidays(startYear);
      if (getYear(end) !== startYear) {
        const h2 = await getPublicHolidays(getYear(end));
        h2.forEach((h) => holidays.add(h));
      }

      const existingSlots = await storage.getSlots(start, addDays(end, 1));

      let currentDay = start;
      let count = 0;
      let updatedCount = 0;

      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");

        if (holidays.has(dateStr)) {
          console.log(`Skipping holiday: ${dateStr}`);
          currentDay = addDays(currentDay, 1);
          continue;
        }

        const dayOfWeek = getDay(currentDay);
        const dayTemplates = FIXED_STUDENT_SCHEDULE.filter(
          (t) => t.day === dayOfWeek
        );

        for (const item of dayTemplates) {
          const [hours, minutes] = item.start.split(":").map(Number);

          // Ustawiamy godzinę na serwerze tak, aby w PL było to, co w grafiku
          // Proste podejście: Tworzymy datę z godziną w czasie lokalnym serwera,
          // a potem sprawdzamy czy w PL to jest ta godzina. Jak nie, korygujemy.
          // ALE prościej: użyjmy setHours na local time (UTC) i założymy, że sloty tworzymy w UTC,
          // a frontend i funkcja GET wyświetlają je w PL.
          // Problem: Jeśli baza ma 10:00 UTC = 11:00 PL.
          // Generator tworzy 11:00 UTC = 12:00 PL.

          // ROZWIĄZANIE: Tworzymy slot tak, aby jego czas w PL wynosił dokładnie 'hours:minutes'.
          // Ponieważ nie mamy tu date-fns-tz pełnego, robimy iteracyjnie.
          let slotStart = setMinutes(setHours(currentDay, hours), minutes);
          const offsetCheck = getWarsawHourMinute(slotStart);

          // Korygujemy różnicę stref
          const diffH = hours - offsetCheck.h;
          if (diffH !== 0) {
            slotStart = addMinutes(slotStart, diffH * 60);
          }

          const slotEnd = addMinutes(slotStart, item.duration);

          const student = allUsers.find(
            (u) =>
              u.name?.toLowerCase().trim() === item.name.toLowerCase().trim() ||
              u.username.toLowerCase().trim() === item.name.toLowerCase().trim()
          );

          // Szukamy istniejącego slotu (tolerancja 2 minuty)
          const existingSlot = existingSlots.find(
            (s) => Math.abs(differenceInMinutes(s.startTime, slotStart)) < 2
          );

          if (existingSlot) {
            await storage.updateSlot(existingSlot.id, {
              isBooked: true,
              studentId: student ? student.id : null,
              topic: item.name,
              endTime: slotEnd,
            });
            updatedCount++;
          } else {
            await storage.createSlot({
              startTime: slotStart,
              endTime: slotEnd,
              isBooked: true,
              studentId: student ? student.id : null,
              isPaid: false,
              topic: item.name,
            });
            count++;
          }
        }

        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({
        count,
        message: `Zaktualizowano ${updatedCount}, utworzono ${count} lekcji.`,
      });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate schedule" });
    }
  });

  app.post("/api/slots/:id/book", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);
      if (!slot) return res.status(404).send("Slot not found");
      if (slot.isBooked) return res.status(409).send("Slot already booked");

      const updated = await storage.updateSlot(id, {
        isBooked: true,
        studentId: user.id,
      });
      res.json(updated);
    } catch (err) {
      res.status(500).send("Error booking slot");
    }
  });

  app.post("/api/slots/:id/cancel", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);
      if (!slot) return res.status(404).send("Slot not found");

      if (user.role !== "admin" && slot.studentId !== user.id) {
        return res.status(403).send("Not authorized");
      }

      if (user.role !== "admin") {
        const hoursUntilLesson = differenceInHours(
          new Date(slot.startTime),
          new Date()
        );
        if (hoursUntilLesson < 24) {
          return res.status(400).json({
            message: "Too late to cancel. Contact admin directly.",
          });
        }
      }

      const updated = await storage.updateSlot(id, {
        isBooked: false,
        studentId: null,
        isPaid: false,
        topic: null,
      });
      res.json(updated);
    } catch (err) {
      res.status(500).send("Error cancelling slot");
    }
  });

  app.post("/api/waitlist", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;
    try {
      const input = insertWaitlistSchema.parse({
        ...req.body,
        userId: user.id,
      });
      const entry = await storage.addToWaitlist(input);
      res.status(201).json(entry);
    } catch (err) {
      res.status(400).json({ message: "Invalid request" });
    }
  });

  if (process.env.NODE_ENV !== "production") {
    const adminUser = await storage.getUserByUsername("admin");
    if (!adminUser) {
      const adminPass = await hashPassword("admin123");
      await storage.createUser({
        username: "admin",
        password: adminPass,
        role: "admin",
        name: "Math Tutor",
      });
    }
  }

  return httpServer;
}
----------------------------------
import { useUser } from "@/hooks/use-auth";
import { Route, useLocation } from "wouter";
import { Loader2 } from "lucide-react";
import React, { useEffect } from "react";

type Props = {
  path: string;
  component: React.ComponentType<any>;
  role?: "admin" | "student";
};

export function ProtectedRoute({ path, component: Component, role }: Props) {
  const { data: user, isLoading } = useUser();
  const [, setLocation] = useLocation();

  useEffect(() => {
    if (!isLoading) {
      if (!user) {
        setLocation("/login");
      } else if (role && user.role !== role) {
        // Przekieruj jeśli rola się nie zgadza (np. student próbuje wejść na admina)
        setLocation(user.role === "admin" ? "/admin" : "/dashboard");
      }
    }
  }, [user, isLoading, role, setLocation]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-background">
        <Loader2 className="w-12 h-12 text-primary animate-spin" />
      </div>
    );
  }

  // Zwróć null podczas przekierowywania
  if (!user || (role && user.role !== role)) {
    return null;
  }

  return <Route path={path} component={Component} />;
}
---------------------------
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    // Ważne dla Passport.js - przesyłanie ciasteczek sesyjnych
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    // Domyślna obsługa zapytań (jeśli nie zdefiniowano queryFn w hooku)
    const res = await fetch(queryKey.join("/") as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false, // Włączamy to ręcznie tylko w kalendarzu
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});
-------------------------------------
import { useUser, useChangePassword } from "@/hooks/use-auth"; // Poprawiony import
import { useSlots, useCancelSlot } from "@/hooks/use-slots";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import { Loader2, Calendar, Clock, XCircle } from "lucide-react";
import { format, formatDistanceToNow, isFuture } from "date-fns";
import { pl } from "date-fns/locale";
import { Link } from "wouter";

const passwordSchema = z.object({
  currentPassword: z.string().min(1, "Current password is required"),
  newPassword: z.string().min(6, "Password must be at least 6 characters"),
});

export default function DashboardPage() {
  // ZMIANA: Używamy useUser zamiast useAuth
  const { data: user } = useUser();

  // Pobieramy sloty z szerokiego zakresu, żeby znaleźć wszystkie przyszłe lekcje
  const { data: slots, isLoading: slotsLoading } = useSlots({
    start: new Date().toISOString(),
    // Pobieramy na rok do przodu
    end: new Date(
      new Date().setFullYear(new Date().getFullYear() + 1)
    ).toISOString(),
  });

  const cancelSlotMutation = useCancelSlot();
  const changePasswordMutation = useChangePassword();

  const form = useForm<z.infer<typeof passwordSchema>>({
    resolver: zodResolver(passwordSchema),
    defaultValues: {
      currentPassword: "",
      newPassword: "",
    },
  });

  if (slotsLoading) {
    return (
      <div className="flex items-center justify-center min-h-[50vh]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  // Filtrujemy tylko lekcje tego użytkownika, które są w przyszłości
  const myUpcomingSlots =
    slots
      ?.filter(
        (slot) =>
          slot.studentId === user?.id && isFuture(new Date(slot.startTime))
      )
      .sort(
        (a, b) =>
          new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
      ) || [];

  const nextLesson = myUpcomingSlots[0];

  function onPasswordSubmit(data: z.infer<typeof passwordSchema>) {
    changePasswordMutation.mutate(data, {
      onSuccess: () => form.reset(),
    });
  }

  return (
    <div className="space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-700">
      {/* NAGŁÓWEK */}
      <div>
        <h1 className="text-3xl font-bold tracking-tight">
          Cześć, {user?.name || user?.username}!
        </h1>
        <p className="text-muted-foreground mt-2">
          Miło Cię widzieć z powrotem. Gotowy na matematykę?
        </p>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* LEWA KOLUMNA - LEKCJE */}
        <div className="space-y-6">
          {/* NASTĘPNA LEKCJA (LICZNIK) */}
          <Card className="bg-primary text-primary-foreground border-none shadow-lg">
            <CardHeader>
              <CardTitle className="text-lg opacity-90">
                Następna lekcja za
              </CardTitle>
            </CardHeader>
            <CardContent>
              {nextLesson ? (
                <div className="space-y-2">
                  <div className="text-4xl font-bold tracking-tighter">
                    {formatDistanceToNow(new Date(nextLesson.startTime), {
                      locale: pl,
                    })}
                  </div>
                  <div className="text-lg opacity-90 font-medium">
                    {format(
                      new Date(nextLesson.startTime),
                      "d MMMM yyyy, HH:mm",
                      { locale: pl }
                    )}
                  </div>
                </div>
              ) : (
                <div className="text-lg opacity-90">
                  Brak zaplanowanych lekcji.
                </div>
              )}
            </CardContent>
          </Card>

          {/* LISTA NADCHODZĄCYCH LEKCJI */}
          <Card>
            <CardHeader className="flex flex-row items-center justify-between">
              <CardTitle>Nadchodzące lekcje</CardTitle>
              <Button variant="outline" size="sm" asChild>
                <Link href="/booking">Zarezerwuj</Link>
              </Button>
            </CardHeader>
            <CardContent>
              {myUpcomingSlots.length === 0 ? (
                <div className="text-center py-6 text-muted-foreground">
                  Brak nadchodzących lekcji.
                  <br />
                  <Link
                    href="/booking"
                    className="text-primary hover:underline mt-2 inline-block"
                  >
                    Zarezerwuj pierwszą lekcję
                  </Link>
                </div>
              ) : (
                <div className="space-y-4">
                  {myUpcomingSlots.map((slot) => (
                    <div
                      key={slot.id}
                      className="flex items-center justify-between p-4 rounded-lg border bg-card hover:bg-accent/5 transition-colors"
                    >
                      <div className="space-y-1">
                        <div className="font-semibold flex items-center gap-2">
                          <Calendar className="h-4 w-4 text-primary" />
                          {format(new Date(slot.startTime), "d MMMM yyyy", {
                            locale: pl,
                          })}
                        </div>
                        <div className="text-sm text-muted-foreground flex items-center gap-2">
                          <Clock className="h-4 w-4" />
                          {format(new Date(slot.startTime), "HH:mm")} -{" "}
                          {format(new Date(slot.endTime), "HH:mm")}
                        </div>
                        <div className="flex gap-2 mt-1">
                          <span
                            className={`text-xs px-2 py-0.5 rounded-full ${
                              slot.isPaid
                                ? "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400"
                                : "bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400"
                            }`}
                          >
                            {slot.isPaid ? "Opłacone" : "Nieopłacone"}
                          </span>
                        </div>
                      </div>

                      {/* PRZYCISK ANULOWANIA */}
                      <Button
                        variant="destructive"
                        size="sm"
                        className="gap-2"
                        onClick={() => {
                          if (
                            confirm("Czy na pewno chcesz anulować tę lekcję?")
                          ) {
                            cancelSlotMutation.mutate(slot.id);
                          }
                        }}
                        disabled={cancelSlotMutation.isPending}
                      >
                        {cancelSlotMutation.isPending ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : (
                          <XCircle className="h-4 w-4" />
                        )}
                        Anuluj
                      </Button>
                    </div>
                  ))}
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        {/* PRAWA KOLUMNA - ZMIANA HASŁA */}
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Zmiana Hasła</CardTitle>
            </CardHeader>
            <CardContent>
              <Form {...form}>
                <form
                  onSubmit={form.handleSubmit(onPasswordSubmit)}
                  className="space-y-4"
                >
                  <FormField
                    control={form.control}
                    name="currentPassword"
                    render={({ field }) => (
                      <FormItem>
                        <Label>Obecne hasło</Label>
                        <FormControl>
                          <Input type="password" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={form.control}
                    name="newPassword"
                    render={({ field }) => (
                      <FormItem>
                        <Label>Nowe hasło</Label>
                        <FormControl>
                          <Input type="password" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <Button
                    type="submit"
                    className="w-full"
                    disabled={changePasswordMutation.isPending}
                  >
                    {changePasswordMutation.isPending && (
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    )}
                    Zmień hasło
                  </Button>
                </form>
              </Form>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
--------------------------------
import { useState } from "react";
import { useSlots, useBookSlot, useAddToWaitlist } from "@/hooks/use-slots";
// ZMIANA: Importujemy useUser (nazwany eksport) zamiast useAuth
import { useUser } from "@/hooks/use-auth";
import { Calendar } from "@/components/ui/calendar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  format,
  startOfWeek,
  endOfWeek,
  eachDayOfInterval,
  isSameDay,
  addWeeks,
  subWeeks,
} from "date-fns";
import { pl } from "date-fns/locale";
import {
  ChevronLeft,
  ChevronRight,
  Clock,
  CalendarCheck,
  BellRing,
} from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";

export default function BookingPage() {
  // ZMIANA: Pobieramy usera z useUser
  const { data: user } = useUser();

  const [selectedDate, setSelectedDate] = useState<Date>(new Date());
  const [currentWeekStart, setCurrentWeekStart] = useState(
    startOfWeek(new Date(), { weekStartsOn: 1 })
  );

  // Pobieramy sloty dla wybranego tygodnia
  const weekStart = currentWeekStart;
  const weekEnd = endOfWeek(currentWeekStart, { weekStartsOn: 1 });
  const { data: slots, isLoading } = useSlots({
    start: weekStart.toISOString(),
    end: weekEnd.toISOString(),
  });

  const bookSlotMutation = useBookSlot();
  const addToWaitlistMutation = useAddToWaitlist();

  // Stan dla modala waitlisty
  const [isWaitlistOpen, setIsWaitlistOpen] = useState(false);
  const [waitlistNote, setWaitlistNote] = useState("");

  const days = eachDayOfInterval({ start: weekStart, end: weekEnd });

  const nextWeek = () => setCurrentWeekStart((date) => addWeeks(date, 1));
  const prevWeek = () => setCurrentWeekStart((date) => subWeeks(date, 1));

  // Filtrowanie slotów dla wybranego dnia
  const selectedDaySlots =
    slots?.filter((slot) =>
      isSameDay(new Date(slot.startTime), selectedDate)
    ) || [];

  // Sortowanie chronologiczne
  selectedDaySlots.sort(
    (a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
  );

  // Sprawdzenie czy są wolne sloty w tym dniu
  const hasFreeSlots = selectedDaySlots.some((s) => !s.isBooked);

  const handleWaitlistSubmit = () => {
    addToWaitlistMutation.mutate(
      { date: selectedDate, notes: waitlistNote },
      {
        onSuccess: () => {
          setIsWaitlistOpen(false);
          setWaitlistNote("");
        },
      }
    );
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[50vh]">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  return (
    <div className="space-y-6 animate-in fade-in slide-in-from-bottom-4 duration-700">
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">
            Zarezerwuj Lekcję
          </h1>
          <p className="text-muted-foreground mt-1">
            Wybierz pasujący Ci termin
          </p>
        </div>

        {/* Nawigacja tygodniami */}
        <div className="flex items-center gap-2 bg-card p-1 rounded-lg border shadow-sm">
          <Button variant="ghost" size="icon" onClick={prevWeek}>
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <span className="text-sm font-medium w-32 text-center">
            {format(weekStart, "MMM d", { locale: pl })} -{" "}
            {format(weekEnd, "MMM d", { locale: pl })}
          </span>
          <Button variant="ghost" size="icon" onClick={nextWeek}>
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-12 gap-6">
        {/* Kolumna lewa: Wybór dnia (Kalendarz tygodniowy) */}
        <Card className="md:col-span-8 shadow-md">
          <CardContent className="p-4">
            <div className="grid grid-cols-7 gap-2 min-w-[600px] md:min-w-0 overflow-x-auto">
              {days.map((day) => {
                const daySlots =
                  slots?.filter((s) => isSameDay(new Date(s.startTime), day)) ||
                  [];
                const freeCount = daySlots.filter((s) => !s.isBooked).length;
                const isSelected = isSameDay(day, selectedDate);
                const isToday = isSameDay(day, new Date());

                return (
                  <button
                    key={day.toISOString()}
                    onClick={() => setSelectedDate(day)}
                    className={`
                      flex flex-col items-center p-3 rounded-xl transition-all duration-200 border
                      ${
                        isSelected
                          ? "bg-primary text-primary-foreground ring-2 ring-primary ring-offset-2 shadow-lg scale-105"
                          : "hover:bg-accent hover:text-accent-foreground bg-card"
                      }
                      ${
                        isToday && !isSelected
                          ? "border-primary/50 bg-primary/5"
                          : "border-transparent"
                      }
                    `}
                  >
                    <span className="text-xs font-medium uppercase tracking-wider opacity-80">
                      {format(day, "EEE", { locale: pl })}
                    </span>
                    <span className="text-xl font-bold my-1">
                      {format(day, "d")}
                    </span>
                    <div className="h-1.5 w-full max-w-[20px] rounded-full bg-border mt-1 overflow-hidden">
                      <div
                        className={`h-full w-full transition-all ${
                          freeCount > 0 ? "bg-green-500" : "bg-border"
                        }`}
                        style={{
                          opacity: freeCount > 0 ? 1 : 0.3,
                        }}
                      />
                    </div>
                  </button>
                );
              })}
            </div>
          </CardContent>
        </Card>

        {/* Kolumna prawa: Lista godzin w wybranym dniu */}
        <Card className="md:col-span-4 h-fit sticky top-6 border-l-4 border-l-primary shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <CalendarCheck className="h-5 w-5 text-primary" />
              {format(selectedDate, "EEEE, d MMMM", { locale: pl })}
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            {selectedDaySlots.length === 0 ? (
              <div className="text-center py-8 space-y-4">
                <p className="text-muted-foreground">
                  Brak wolnych terminów w tym dniu.
                </p>
                {/* PRZYCISK LISTY REZERWOWEJ */}
                <Dialog open={isWaitlistOpen} onOpenChange={setIsWaitlistOpen}>
                  <DialogTrigger asChild>
                    <Button variant="outline" className="gap-2 w-full">
                      <BellRing className="h-4 w-4" />
                      Powiadom o dostępności
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>Zapisz się na listę rezerwową</DialogTitle>
                      <DialogDescription>
                        Jeśli zwolni się termin w dniu{" "}
                        <span className="font-semibold text-foreground">
                          {format(selectedDate, "d MMMM yyyy", { locale: pl })}
                        </span>
                        , powiadomimy Cię mailowo.
                      </DialogDescription>
                    </DialogHeader>
                    <div className="grid gap-4 py-4">
                      <div className="grid gap-2">
                        <Label htmlFor="notes">
                          Notatka (opcjonalnie, np. preferowana godzina)
                        </Label>
                        <Input
                          id="notes"
                          placeholder="np. po godzinie 16:00"
                          value={waitlistNote}
                          onChange={(e) => setWaitlistNote(e.target.value)}
                        />
                      </div>
                    </div>
                    <DialogFooter>
                      <Button
                        onClick={handleWaitlistSubmit}
                        disabled={addToWaitlistMutation.isPending}
                      >
                        {addToWaitlistMutation.isPending
                          ? "Zapisywanie..."
                          : "Zapisz mnie"}
                      </Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>
            ) : (
              <div className="grid gap-3">
                {selectedDaySlots.map((slot) => {
                  const isMyBooking =
                    slot.isBooked && slot.studentId === user?.id;
                  const isBookedByOther =
                    slot.isBooked && slot.studentId !== user?.id;

                  if (isBookedByOther) return null; // Ukrywamy zajęte przez innych

                  return (
                    <div
                      key={slot.id}
                      className={`
                        p-3 rounded-lg border flex items-center justify-between transition-all
                        ${
                          isMyBooking
                            ? "bg-primary/10 border-primary"
                            : "hover:border-primary bg-card"
                        }
                      `}
                    >
                      <div className="flex items-center gap-3">
                        <Clock
                          className={`h-4 w-4 ${
                            isMyBooking
                              ? "text-primary"
                              : "text-muted-foreground"
                          }`}
                        />
                        <span
                          className={`font-semibold ${
                            isMyBooking ? "text-primary" : ""
                          }`}
                        >
                          {format(new Date(slot.startTime), "HH:mm")}
                        </span>
                      </div>

                      {isMyBooking ? (
                        <span className="text-xs font-medium text-primary bg-primary/10 px-2 py-1 rounded">
                          Twoja Rezerwacja
                        </span>
                      ) : (
                        <Button
                          size="sm"
                          onClick={() => bookSlotMutation.mutate(slot.id)}
                          disabled={bookSlotMutation.isPending}
                        >
                          Rezerwuj
                        </Button>
                      )}
                    </div>
                  );
                })}

                {/* Jeśli w dniu są same zajęte sloty (ukryte), też pokaż Waitlistę */}
                {!hasFreeSlots && (
                  <div className="mt-4 pt-4 border-t">
                    <p className="text-sm text-muted-foreground text-center mb-3">
                      Wszystkie godziny są zajęte.
                    </p>
                    <Dialog
                      open={isWaitlistOpen}
                      onOpenChange={setIsWaitlistOpen}
                    >
                      <DialogTrigger asChild>
                        <Button variant="outline" className="gap-2 w-full">
                          <BellRing className="h-4 w-4" />
                          Powiadom o dostępności
                        </Button>
                      </DialogTrigger>
                      <DialogContent>
                        <DialogHeader>
                          <DialogTitle>
                            Zapisz się na listę rezerwową
                          </DialogTitle>
                          <DialogDescription>
                            Dla dnia:{" "}
                            {format(selectedDate, "d MMMM", { locale: pl })}
                          </DialogDescription>
                        </DialogHeader>
                        <div className="grid gap-4 py-4">
                          <div className="grid gap-2">
                            <Label htmlFor="notes-2">Notatka</Label>
                            <Input
                              id="notes-2"
                              placeholder="Preferencje..."
                              value={waitlistNote}
                              onChange={(e) => setWaitlistNote(e.target.value)}
                            />
                          </div>
                        </div>
                        <DialogFooter>
                          <Button
                            onClick={handleWaitlistSubmit}
                            disabled={addToWaitlistMutation.isPending}
                          >
                            Zapisz mnie
                          </Button>
                        </DialogFooter>
                      </DialogContent>
                    </Dialog>
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
--------------------------------
import type { Express } from "express";
import type { Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";
// NOWOŚĆ: Import serwisu email
import { sendWaitlistNotification } from "./services/email";
import {
  insertSlotSchema,
  generateSlotsSchema,
  insertWaitlistSchema,
  insertWeeklyScheduleSchema,
  generateFromTemplateSchema,
  insertUserSchema,
  type User,
} from "@shared/schema";
import { z } from "zod";
import {
  addDays,
  setHours,
  setMinutes,
  parseISO,
  differenceInHours,
  format,
  getYear,
  getDay,
  addMinutes,
  areIntervalsOverlapping,
  differenceInMinutes,
} from "date-fns";
// NOWOŚĆ: Lokalizacja PL do formatowania daty w mailu
import { pl } from "date-fns/locale";
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

// --- POMOCNIKI CZASU (STREFA PL) ---

// Zwraca godzinę i minutę w czasie warszawskim dla danej daty UTC
function getWarsawHourMinute(date: Date) {
  // Konwertujemy datę na string w strefie Europe/Warsaw
  const plTimeStr = date.toLocaleString("en-US", {
    timeZone: "Europe/Warsaw",
    hour12: false,
    hour: "2-digit",
    minute: "2-digit",
  });
  const [h, m] = plTimeStr.split(":").map(Number);
  // Obsługa przypadku 24:00 (rzadkie, ale możliwe w niektórych implementacjach)
  return { h: h === 24 ? 0 : h, m };
}

// Sprawdza czy data to konkretny dzień tygodnia i godzina (wg czasu PL)
function isWarsawTime(
  date: Date,
  targetDay: number,
  targetH: number,
  targetM: number
) {
  const day = getDay(date); // getDay zwraca dzień lokalny, ale dla bezpieczeństwa sprawdzamy string
  const plDateStr = date.toLocaleString("en-US", {
    timeZone: "Europe/Warsaw",
    weekday: "short",
  });
  // Mapowanie dni: Sun=0, Mon=1...
  const daysMap: Record<string, number> = {
    Sun: 0,
    Mon: 1,
    Tue: 2,
    Wed: 3,
    Thu: 4,
    Fri: 5,
    Sat: 6,
  };
  const currentDay = daysMap[plDateStr.split(",")[0]] ?? day;

  if (currentDay !== targetDay) return false;

  const { h, m } = getWarsawHourMinute(date);
  return h === targetH && Math.abs(m - targetM) < 2; // Tolerancja 1 minuty
}

// Cache dla świąt
const holidayCache = new Map<number, Set<string>>();

async function getPublicHolidays(year: number): Promise<Set<string>> {
  if (holidayCache.has(year)) {
    return holidayCache.get(year)!;
  }

  try {
    console.log(`Fetching public holidays for year ${year}...`);
    const response = await fetch(
      `https://date.nager.at/api/v3/PublicHolidays/${year}/PL`
    );
    if (!response.ok) return new Set();
    const data = (await response.json()) as { date: string }[];
    const holidays = new Set(data.map((h) => h.date));
    holidayCache.set(year, holidays);
    return holidays;
  } catch (error) {
    console.error("Failed to fetch holidays:", error);
    return new Set();
  }
}

// --- STAŁY GRAFIK UCZNIÓW ---
const FIXED_STUDENT_SCHEDULE = [
  // Poniedziałek (1)
  { day: 1, start: "11:00", duration: 60, name: "Masia S." },
  { day: 1, start: "13:30", duration: 60, name: "Natasza Z." },
  { day: 1, start: "14:50", duration: 60, name: "Marcel M." },
  { day: 1, start: "16:30", duration: 60, name: "Martyna S." },
  { day: 1, start: "17:50", duration: 60, name: "Ksawery D." },
  { day: 1, start: "19:00", duration: 60, name: "Filip B." },

  // Wtorek (2)
  { day: 2, start: "12:00", duration: 120, name: "Julka B." },
  { day: 2, start: "14:30", duration: 60, name: "Oskar Z." },
  { day: 2, start: "16:20", duration: 60, name: "Wiktor B." },
  { day: 2, start: "18:00", duration: 60, name: "Julka S." },
  { day: 2, start: "19:00", duration: 60, name: "Tobiasz S." },

  // Środa (3)
  { day: 3, start: "12:00", duration: 60, name: "Franek L." },
  { day: 3, start: "14:40", duration: 60, name: "Mateusz M." },
  { day: 3, start: "16:15", duration: 90, name: "Olek P." },
  { day: 3, start: "18:00", duration: 60, name: "Olek Ś." },

  // Czwartek (4)
  { day: 4, start: "12:10", duration: 60, name: "Ola S." },
  { day: 4, start: "14:50", duration: 60, name: "Michał G." },
  { day: 4, start: "16:30", duration: 60, name: "Paweł S." },
  { day: 4, start: "17:45", duration: 60, name: "Małgosia K." },
  { day: 4, start: "19:00", duration: 60, name: "Adam L." },

  // Piątek (5)
  { day: 5, start: "13:30", duration: 60, name: "Oskar Z." },
  { day: 5, start: "14:30", duration: 60, name: "Pola M." },
  { day: 5, start: "16:30", duration: 60, name: "Natalia B." },
  { day: 5, start: "18:00", duration: 120, name: "Kacper M." },

  // Sobota (6)
  { day: 6, start: "08:45", duration: 90, name: "Michał W." },
  { day: 6, start: "10:30", duration: 120, name: "Oliwia P." },
  { day: 6, start: "13:00", duration: 60, name: "Kacper D." },
  { day: 6, start: "14:30", duration: 60, name: "Janek P." },
  { day: 6, start: "15:30", duration: 60, name: "Oskar N." },
  { day: 6, start: "17:00", duration: 90, name: "Antek Ż." },
];

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  setupAuth(app);

  app.get("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    res.header("Cache-Control", "no-store, max-age=0");
    const users = await storage.getAllUsers();
    res.json(users);
  });

  app.post("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const userData = insertUserSchema.parse(req.body);
      const existingUser = await storage.getUserByUsername(userData.username);
      if (existingUser) {
        return res.status(409).json({ message: "Użytkownik już istnieje." });
      }
      const hashedPassword = await hashPassword(userData.password);
      const newUser = await storage.createUser({
        ...userData,
        password: hashedPassword,
        role: "student",
      });
      res.status(201).json(newUser);
    } catch (err) {
      if (err instanceof z.ZodError) {
        res.status(400).json({ message: err.issues[0].message });
      } else {
        res.status(500).json({ message: "Internal server error" });
      }
    }
  });

  app.delete("/api/users/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteUser(id);
    res.sendStatus(204);
  });

  // --- SLOTY ---

  app.get("/api/slots", async (req, res) => {
    try {
      const start = req.query.start
        ? new Date(req.query.start as string)
        : undefined;
      const end = req.query.end ? new Date(req.query.end as string) : undefined;

      const slots = await storage.getSlots(start, end);
      if (slots.length === 0) return res.json(slots);

      const years = new Set(slots.map((s) => getYear(s.startTime)));
      const holidaySets = await Promise.all(
        Array.from(years).map((y) => getPublicHolidays(y))
      );
      const allHolidays = new Set<string>();
      holidaySets.forEach((set) =>
        set.forEach((date) => allHolidays.add(date))
      );

      const filteredSlots = slots.filter((slot) => {
        if (slot.isBooked) return true; // Zarezerwowane zawsze pokazujemy

        const dateStr = format(slot.startTime, "yyyy-MM-dd");
        // Ukryj wolne sloty w święta
        if (allHolidays.has(dateStr)) return false;

        // --- FILTR KOLIZJI (Z UWZGLĘDNIENIEM STREFY CZASOWEJ) ---
        const dayOfWeek = getDay(slot.startTime); // 0-6
        const dailyFixed = FIXED_STUDENT_SCHEDULE.filter(
          (l) => l.day === dayOfWeek
        );

        // Pobieramy godzinę startu slotu w czasie PL
        const slotPl = getWarsawHourMinute(slot.startTime);
        const slotStartMinutes = slotPl.h * 60 + slotPl.m;
        // Obliczamy długość slotu w minutach
        const duration = differenceInMinutes(slot.endTime, slot.startTime);
        const slotEndMinutes = slotStartMinutes + duration;

        const hasCollision = dailyFixed.some((fixedLesson) => {
          const [fh, fm] = fixedLesson.start.split(":").map(Number);
          const fixedStartMinutes = fh * 60 + fm;
          const fixedEndMinutes = fixedStartMinutes + fixedLesson.duration;

          // Sprawdzamy nakładanie się przedziałów (czas PL vs czas PL)
          return (
            slotStartMinutes < fixedEndMinutes &&
            slotEndMinutes > fixedStartMinutes
          );
        });

        if (hasCollision) return false;

        return true;
      });

      res.json(filteredSlots);
    } catch (err) {
      res.status(500).json({ message: "Failed to fetch slots" });
    }
  });

  app.post("/api/slots", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertSlotSchema.parse(req.body);
      const slot = await storage.createSlot(input);
      res.status(201).json(slot);
    } catch (err) {
      res.status(400).json({ message: "Error creating slot" });
    }
  });

  app.patch("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const id = parseInt(req.params.id);
      const input = insertSlotSchema.partial().parse(req.body);
      const updated = await storage.updateSlot(id, input);
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Failed to update slot" });
    }
  });

  app.delete("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteSlot(id);
    res.sendStatus(204);
  });

  app.get("/api/weekly-schedule", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const schedule = await storage.getWeeklySchedule();
    res.json(schedule);
  });

  app.post("/api/weekly-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertWeeklyScheduleSchema.parse(req.body);
      const item = await storage.createWeeklyScheduleItem(input);
      res.status(201).json(item);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/weekly-schedule/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteWeeklyScheduleItem(id);
    res.sendStatus(204);
  });

  // --- GENERATORY ---

  // 1. ZWYKŁY GENERATOR
  app.post("/api/slots/generate", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const { startDate, endDate, startTime, endTime, duration } =
        generateSlotsSchema.parse(req.body);

      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const startYear = getYear(start);
      const holidays = await getPublicHolidays(startYear);
      if (getYear(end) !== startYear) {
        const h2 = await getPublicHolidays(getYear(end));
        h2.forEach((h) => holidays.add(h));
      }

      const existingSlots = await storage.getSlots(start, addDays(end, 1));
      const existingTimestamps = new Set(
        existingSlots.map((s) => s.startTime.getTime())
      );

      const [startHour, startMinute] = startTime.split(":").map(Number);
      const [endHour, endMinute] = endTime.split(":").map(Number);

      let currentDay = start;
      let count = 0;

      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");
        const dayOfWeek = getDay(currentDay);

        if (holidays.has(dateStr)) {
          currentDay = addDays(currentDay, 1);
          continue;
        }

        if (dayOfWeek !== 0) {
          const fixedLessons = FIXED_STUDENT_SCHEDULE.filter(
            (l) => l.day === dayOfWeek
          );

          let daySlotStart = setMinutes(
            setHours(currentDay, startHour),
            startMinute
          );
          const daySlotEnd = setMinutes(
            setHours(currentDay, endHour),
            endMinute
          );

          while (daySlotStart < daySlotEnd) {
            const slotEnd = addMinutes(daySlotStart, duration);
            if (slotEnd > daySlotEnd) break;

            // Sprawdzenie kolizji w czasie PL
            const { h: slotH, m: slotM } = getWarsawHourMinute(daySlotStart);
            const slotStartMin = slotH * 60 + slotM;
            const slotEndMin = slotStartMin + duration;

            const isCollision = fixedLessons.some((lesson) => {
              const [lh, lm] = lesson.start.split(":").map(Number);
              const lessonStartMin = lh * 60 + lm;
              const lessonEndMin = lessonStartMin + lesson.duration;

              return slotStartMin < lessonEndMin && slotEndMin > lessonStartMin;
            });

            if (
              !isCollision &&
              !existingTimestamps.has(daySlotStart.getTime())
            ) {
              await storage.createSlot({
                startTime: daySlotStart,
                endTime: slotEnd,
                isBooked: false,
                isPaid: false,
              });
              count++;
            }
            daySlotStart = slotEnd;
          }
        }
        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({ count });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate slots" });
    }
  });

  // 2. GENERATOR ZE SZABLONU
  app.post("/api/slots/generate-from-template", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const { startDate, endDate } = generateFromTemplateSchema.parse(req.body);
      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const allUsers = await storage.getAllUsers();

      const startYear = getYear(start);
      const holidays = await getPublicHolidays(startYear);
      if (getYear(end) !== startYear) {
        const h2 = await getPublicHolidays(getYear(end));
        h2.forEach((h) => holidays.add(h));
      }

      const existingSlots = await storage.getSlots(start, addDays(end, 1));

      let currentDay = start;
      let count = 0;
      let updatedCount = 0;

      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");

        if (holidays.has(dateStr)) {
          console.log(`Skipping holiday: ${dateStr}`);
          currentDay = addDays(currentDay, 1);
          continue;
        }

        const dayOfWeek = getDay(currentDay);
        const dayTemplates = FIXED_STUDENT_SCHEDULE.filter(
          (t) => t.day === dayOfWeek
        );

        for (const item of dayTemplates) {
          const [hours, minutes] = item.start.split(":").map(Number);

          let slotStart = setMinutes(setHours(currentDay, hours), minutes);
          const offsetCheck = getWarsawHourMinute(slotStart);
          const diffH = hours - offsetCheck.h;
          if (diffH !== 0) {
            slotStart = addMinutes(slotStart, diffH * 60);
          }

          const slotEnd = addMinutes(slotStart, item.duration);

          const student = allUsers.find(
            (u) =>
              u.name?.toLowerCase().trim() === item.name.toLowerCase().trim() ||
              u.username.toLowerCase().trim() === item.name.toLowerCase().trim()
          );

          const existingSlot = existingSlots.find(
            (s) => Math.abs(differenceInMinutes(s.startTime, slotStart)) < 2
          );

          if (existingSlot) {
            await storage.updateSlot(existingSlot.id, {
              isBooked: true,
              studentId: student ? student.id : null,
              topic: item.name,
              endTime: slotEnd,
            });
            updatedCount++;
          } else {
            await storage.createSlot({
              startTime: slotStart,
              endTime: slotEnd,
              isBooked: true,
              studentId: student ? student.id : null,
              isPaid: false,
              topic: item.name,
            });
            count++;
          }
        }

        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({
        count,
        message: `Zaktualizowano ${updatedCount}, utworzono ${count} lekcji.`,
      });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate schedule" });
    }
  });

  app.post("/api/slots/:id/book", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);
      if (!slot) return res.status(404).send("Slot not found");
      if (slot.isBooked) return res.status(409).send("Slot already booked");

      const updated = await storage.updateSlot(id, {
        isBooked: true,
        studentId: user.id,
      });
      res.json(updated);
    } catch (err) {
      res.status(500).send("Error booking slot");
    }
  });

  // --- ZMODYFIKOWANY ENDPOINT: ANULOWANIE LEKCJI Z POWIADOMIENIAMI ---
  app.post("/api/slots/:id/cancel", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);
      if (!slot) return res.status(404).send("Slot not found");

      if (user.role !== "admin" && slot.studentId !== user.id) {
        return res.status(403).send("Not authorized");
      }

      if (user.role !== "admin") {
        const hoursUntilLesson = differenceInHours(
          new Date(slot.startTime),
          new Date()
        );
        if (hoursUntilLesson < 24) {
          return res.status(400).json({
            message: "Too late to cancel. Contact admin directly.",
          });
        }
      }

      const updated = await storage.updateSlot(id, {
        isBooked: false,
        studentId: null,
        isPaid: false,
        topic: null,
      });

      // --- LOGIKA POWIADOMIEŃ START ---
      try {
        const slotDate = new Date(slot.startTime);
        console.log(
          `[WAITLIST] Checking waitlist for ${format(slotDate, "yyyy-MM-dd")}`
        );

        // Symulacja wysłania powiadomienia (Mock)
        // W przyszłości tutaj dodamy pobieranie userów z listy rezerwowej
        await sendWaitlistNotification({
          email: "uczen@przyklad.pl",
          name: "Oczekujący Uczeń",
          date: format(slotDate, "dd MMMM yyyy", { locale: pl }),
          time: format(slotDate, "HH:mm"),
        });
      } catch (e) {
        console.error("Failed to process waitlist notification", e);
        // Nie przerywamy requestu, nawet jak mail nie pójdzie
      }
      // --- LOGIKA POWIADOMIEŃ KONIEC ---

      res.json(updated);
    } catch (err) {
      res.status(500).send("Error cancelling slot");
    }
  });

  app.post("/api/waitlist", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;
    try {
      const input = insertWaitlistSchema.parse({
        ...req.body,
        userId: user.id,
      });
      const entry = await storage.addToWaitlist(input);
      res.status(201).json(entry);
    } catch (err) {
      res.status(400).json({ message: "Invalid request" });
    }
  });

  if (process.env.NODE_ENV !== "production") {
    const adminUser = await storage.getUserByUsername("admin");
    if (!adminUser) {
      const adminPass = await hashPassword("admin123");
      await storage.createUser({
        username: "admin",
        password: adminPass,
        role: "admin",
        name: "Math Tutor",
      });
    }
  }

  return httpServer;
}
-----------------------------
import type { Express } from "express";
import type { Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";
// ✅ DODANO: Import serwisu email (żeby log się wyświetlił)
import { sendWaitlistNotification } from "./services/email";
import {
  insertSlotSchema,
  generateSlotsSchema,
  insertWaitlistSchema,
  insertWeeklyScheduleSchema,
  generateFromTemplateSchema,
  insertUserSchema,
  type User,
} from "@shared/schema";
import { z } from "zod";
import {
  addDays,
  setHours,
  setMinutes,
  parseISO,
  differenceInHours,
  format,
  getYear,
  getDay,
  addMinutes,
  areIntervalsOverlapping,
  differenceInMinutes,
} from "date-fns";
// ✅ DODANO: Lokalizacja PL do ładnej daty w logu
import { pl } from "date-fns/locale";
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

// --- POMOCNIKI CZASU (STREFA PL) ---

// Zwraca godzinę i minutę w czasie warszawskim dla danej daty UTC
function getWarsawHourMinute(date: Date) {
  // Konwertujemy datę na string w strefie Europe/Warsaw
  const plTimeStr = date.toLocaleString("en-US", {
    timeZone: "Europe/Warsaw",
    hour12: false,
    hour: "2-digit",
    minute: "2-digit",
  });
  const [h, m] = plTimeStr.split(":").map(Number);
  // Obsługa przypadku 24:00 (rzadkie, ale możliwe w niektórych implementacjach)
  return { h: h === 24 ? 0 : h, m };
}

// Sprawdza czy data to konkretny dzień tygodnia i godzina (wg czasu PL)
function isWarsawTime(
  date: Date,
  targetDay: number,
  targetH: number,
  targetM: number
) {
  const day = getDay(date); // getDay zwraca dzień lokalny, ale dla bezpieczeństwa sprawdzamy string
  const plDateStr = date.toLocaleString("en-US", {
    timeZone: "Europe/Warsaw",
    weekday: "short",
  });
  // Mapowanie dni: Sun=0, Mon=1...
  const daysMap: Record<string, number> = {
    Sun: 0,
    Mon: 1,
    Tue: 2,
    Wed: 3,
    Thu: 4,
    Fri: 5,
    Sat: 6,
  };
  const currentDay = daysMap[plDateStr.split(",")[0]] ?? day;

  if (currentDay !== targetDay) return false;

  const { h, m } = getWarsawHourMinute(date);
  return h === targetH && Math.abs(m - targetM) < 2; // Tolerancja 1 minuty
}

// Cache dla świąt
const holidayCache = new Map<number, Set<string>>();

async function getPublicHolidays(year: number): Promise<Set<string>> {
  if (holidayCache.has(year)) {
    return holidayCache.get(year)!;
  }

  try {
    console.log(`Fetching public holidays for year ${year}...`);
    const response = await fetch(
      `https://date.nager.at/api/v3/PublicHolidays/${year}/PL`
    );
    if (!response.ok) return new Set();
    const data = (await response.json()) as { date: string }[];
    const holidays = new Set(data.map((h) => h.date));
    holidayCache.set(year, holidays);
    return holidays;
  } catch (error) {
    console.error("Failed to fetch holidays:", error);
    return new Set();
  }
}

// --- STAŁY GRAFIK UCZNIÓW ---
const FIXED_STUDENT_SCHEDULE = [
  // Poniedziałek (1)
  { day: 1, start: "11:00", duration: 60, name: "Masia S." },
  { day: 1, start: "13:30", duration: 60, name: "Natasza Z." },
  { day: 1, start: "14:50", duration: 60, name: "Marcel M." },
  { day: 1, start: "16:30", duration: 60, name: "Martyna S." },
  { day: 1, start: "17:50", duration: 60, name: "Ksawery D." },
  { day: 1, start: "19:00", duration: 60, name: "Filip B." },

  // Wtorek (2)
  { day: 2, start: "12:00", duration: 120, name: "Julka B." },
  { day: 2, start: "14:30", duration: 60, name: "Oskar Z." },
  { day: 2, start: "16:20", duration: 60, name: "Wiktor B." },
  { day: 2, start: "18:00", duration: 60, name: "Julka S." },
  { day: 2, start: "19:00", duration: 60, name: "Tobiasz S." },

  // Środa (3)
  { day: 3, start: "12:00", duration: 60, name: "Franek L." },
  { day: 3, start: "14:40", duration: 60, name: "Mateusz M." },
  { day: 3, start: "16:15", duration: 90, name: "Olek P." },
  { day: 3, start: "18:00", duration: 60, name: "Olek Ś." },

  // Czwartek (4)
  { day: 4, start: "12:10", duration: 60, name: "Ola S." },
  { day: 4, start: "14:50", duration: 60, name: "Michał G." },
  { day: 4, start: "16:30", duration: 60, name: "Paweł S." },
  { day: 4, start: "17:45", duration: 60, name: "Małgosia K." },
  { day: 4, start: "19:00", duration: 60, name: "Adam L." },

  // Piątek (5)
  { day: 5, start: "13:30", duration: 60, name: "Oskar Z." },
  { day: 5, start: "14:30", duration: 60, name: "Pola M." },
  { day: 5, start: "16:30", duration: 60, name: "Natalia B." },
  { day: 5, start: "18:00", duration: 120, name: "Kacper M." },

  // Sobota (6)
  { day: 6, start: "08:45", duration: 90, name: "Michał W." },
  { day: 6, start: "10:30", duration: 120, name: "Oliwia P." },
  { day: 6, start: "13:00", duration: 60, name: "Kacper D." },
  { day: 6, start: "14:30", duration: 60, name: "Janek P." },
  { day: 6, start: "15:30", duration: 60, name: "Oskar N." },
  { day: 6, start: "17:00", duration: 90, name: "Antek Ż." },
];

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  setupAuth(app);

  app.get("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    res.header("Cache-Control", "no-store, max-age=0");
    const users = await storage.getAllUsers();
    res.json(users);
  });

  app.post("/api/users", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const userData = insertUserSchema.parse(req.body);
      const existingUser = await storage.getUserByUsername(userData.username);
      if (existingUser) {
        return res.status(409).json({ message: "Użytkownik już istnieje." });
      }
      const hashedPassword = await hashPassword(userData.password);
      const newUser = await storage.createUser({
        ...userData,
        password: hashedPassword,
        role: "student",
      });
      res.status(201).json(newUser);
    } catch (err) {
      if (err instanceof z.ZodError) {
        res.status(400).json({ message: err.issues[0].message });
      } else {
        res.status(500).json({ message: "Internal server error" });
      }
    }
  });

  app.delete("/api/users/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteUser(id);
    res.sendStatus(204);
  });

  // --- SLOTY ---

  app.get("/api/slots", async (req, res) => {
    try {
      const start = req.query.start
        ? new Date(req.query.start as string)
        : undefined;
      const end = req.query.end ? new Date(req.query.end as string) : undefined;

      const slots = await storage.getSlots(start, end);
      if (slots.length === 0) return res.json(slots);

      const years = new Set(slots.map((s) => getYear(s.startTime)));
      const holidaySets = await Promise.all(
        Array.from(years).map((y) => getPublicHolidays(y))
      );
      const allHolidays = new Set<string>();
      holidaySets.forEach((set) =>
        set.forEach((date) => allHolidays.add(date))
      );

      const filteredSlots = slots.filter((slot) => {
        if (slot.isBooked) return true; // Zarezerwowane zawsze pokazujemy

        const dateStr = format(slot.startTime, "yyyy-MM-dd");
        // Ukryj wolne sloty w święta
        if (allHolidays.has(dateStr)) return false;

        // --- FILTR KOLIZJI (Z UWZGLĘDNIENIEM STREFY CZASOWEJ) ---
        const dayOfWeek = getDay(slot.startTime); // 0-6
        const dailyFixed = FIXED_STUDENT_SCHEDULE.filter(
          (l) => l.day === dayOfWeek
        );

        // Pobieramy godzinę startu slotu w czasie PL
        const slotPl = getWarsawHourMinute(slot.startTime);
        const slotStartMinutes = slotPl.h * 60 + slotPl.m;
        // Obliczamy długość slotu w minutach
        const duration = differenceInMinutes(slot.endTime, slot.startTime);
        const slotEndMinutes = slotStartMinutes + duration;

        const hasCollision = dailyFixed.some((fixedLesson) => {
          const [fh, fm] = fixedLesson.start.split(":").map(Number);
          const fixedStartMinutes = fh * 60 + fm;
          const fixedEndMinutes = fixedStartMinutes + fixedLesson.duration;

          // Sprawdzamy nakładanie się przedziałów (czas PL vs czas PL)
          return (
            slotStartMinutes < fixedEndMinutes &&
            slotEndMinutes > fixedStartMinutes
          );
        });

        if (hasCollision) return false;

        return true;
      });

      res.json(filteredSlots);
    } catch (err) {
      res.status(500).json({ message: "Failed to fetch slots" });
    }
  });

  app.post("/api/slots", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertSlotSchema.parse(req.body);
      const slot = await storage.createSlot(input);
      res.status(201).json(slot);
    } catch (err) {
      res.status(400).json({ message: "Error creating slot" });
    }
  });

  app.patch("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const id = parseInt(req.params.id);
      const input = insertSlotSchema.partial().parse(req.body);
      const updated = await storage.updateSlot(id, input);
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Failed to update slot" });
    }
  });

  app.delete("/api/slots/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteSlot(id);
    res.sendStatus(204);
  });

  app.get("/api/weekly-schedule", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const schedule = await storage.getWeeklySchedule();
    res.json(schedule);
  });

  app.post("/api/weekly-schedule", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const input = insertWeeklyScheduleSchema.parse(req.body);
      const item = await storage.createWeeklyScheduleItem(input);
      res.status(201).json(item);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/weekly-schedule/:id", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    const id = parseInt(req.params.id);
    await storage.deleteWeeklyScheduleItem(id);
    res.sendStatus(204);
  });

  // --- GENERATORY ---

  // 1. ZWYKŁY GENERATOR (Tworzy wolne sloty, uwzględnia strefę czasową PL przy kolizjach)
  app.post("/api/slots/generate", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }
    try {
      const { startDate, endDate, startTime, endTime, duration } =
        generateSlotsSchema.parse(req.body);

      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const startYear = getYear(start);
      const holidays = await getPublicHolidays(startYear);
      if (getYear(end) !== startYear) {
        const h2 = await getPublicHolidays(getYear(end));
        h2.forEach((h) => holidays.add(h));
      }

      const existingSlots = await storage.getSlots(start, addDays(end, 1));
      const existingTimestamps = new Set(
        existingSlots.map((s) => s.startTime.getTime())
      );

      const [startHour, startMinute] = startTime.split(":").map(Number);
      const [endHour, endMinute] = endTime.split(":").map(Number);

      let currentDay = start;
      let count = 0;

      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");
        const dayOfWeek = getDay(currentDay);

        if (holidays.has(dateStr)) {
          currentDay = addDays(currentDay, 1);
          continue;
        }

        if (dayOfWeek !== 0) {
          const fixedLessons = FIXED_STUDENT_SCHEDULE.filter(
            (l) => l.day === dayOfWeek
          );

          let daySlotStart = setMinutes(
            setHours(currentDay, startHour),
            startMinute
          );
          const daySlotEnd = setMinutes(
            setHours(currentDay, endHour),
            endMinute
          );

          while (daySlotStart < daySlotEnd) {
            const slotEnd = addMinutes(daySlotStart, duration);
            if (slotEnd > daySlotEnd) break;

            // Sprawdzenie kolizji w czasie PL
            const { h: slotH, m: slotM } = getWarsawHourMinute(daySlotStart);
            const slotStartMin = slotH * 60 + slotM;
            const slotEndMin = slotStartMin + duration;

            const isCollision = fixedLessons.some((lesson) => {
              const [lh, lm] = lesson.start.split(":").map(Number);
              const lessonStartMin = lh * 60 + lm;
              const lessonEndMin = lessonStartMin + lesson.duration;

              return slotStartMin < lessonEndMin && slotEndMin > lessonStartMin;
            });

            if (
              !isCollision &&
              !existingTimestamps.has(daySlotStart.getTime())
            ) {
              await storage.createSlot({
                startTime: daySlotStart,
                endTime: slotEnd,
                isBooked: false,
                isPaid: false,
              });
              count++;
            }
            daySlotStart = slotEnd;
          }
        }
        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({ count });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate slots" });
    }
  });

  // 2. GENERATOR ZE SZABLONU (NAPRAWIA I TWORZY - z obsługą strefy czasowej PL)
  app.post("/api/slots/generate-from-template", async (req, res) => {
    const user = req.user as User;
    if (!req.isAuthenticated() || user.role !== "admin") {
      return res.status(403).send("Unauthorized");
    }

    try {
      const { startDate, endDate } = generateFromTemplateSchema.parse(req.body);
      const start = parseISO(startDate);
      const end = parseISO(endDate);

      const allUsers = await storage.getAllUsers();

      const startYear = getYear(start);
      const holidays = await getPublicHolidays(startYear);
      if (getYear(end) !== startYear) {
        const h2 = await getPublicHolidays(getYear(end));
        h2.forEach((h) => holidays.add(h));
      }

      const existingSlots = await storage.getSlots(start, addDays(end, 1));

      let currentDay = start;
      let count = 0;
      let updatedCount = 0;

      while (currentDay <= end) {
        const dateStr = format(currentDay, "yyyy-MM-dd");

        if (holidays.has(dateStr)) {
          console.log(`Skipping holiday: ${dateStr}`);
          currentDay = addDays(currentDay, 1);
          continue;
        }

        const dayOfWeek = getDay(currentDay);
        const dayTemplates = FIXED_STUDENT_SCHEDULE.filter(
          (t) => t.day === dayOfWeek
        );

        for (const item of dayTemplates) {
          const [hours, minutes] = item.start.split(":").map(Number);

          let slotStart = setMinutes(setHours(currentDay, hours), minutes);
          const offsetCheck = getWarsawHourMinute(slotStart);
          const diffH = hours - offsetCheck.h;
          if (diffH !== 0) {
            slotStart = addMinutes(slotStart, diffH * 60);
          }

          const slotEnd = addMinutes(slotStart, item.duration);

          const student = allUsers.find(
            (u) =>
              u.name?.toLowerCase().trim() === item.name.toLowerCase().trim() ||
              u.username.toLowerCase().trim() === item.name.toLowerCase().trim()
          );

          const existingSlot = existingSlots.find(
            (s) => Math.abs(differenceInMinutes(s.startTime, slotStart)) < 2
          );

          if (existingSlot) {
            await storage.updateSlot(existingSlot.id, {
              isBooked: true,
              studentId: student ? student.id : null,
              topic: item.name,
              endTime: slotEnd,
            });
            updatedCount++;
          } else {
            await storage.createSlot({
              startTime: slotStart,
              endTime: slotEnd,
              isBooked: true,
              studentId: student ? student.id : null,
              isPaid: false,
              topic: item.name,
            });
            count++;
          }
        }

        currentDay = addDays(currentDay, 1);
      }

      res.status(201).json({
        count,
        message: `Zaktualizowano ${updatedCount}, utworzono ${count} lekcji.`,
      });
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to generate schedule" });
    }
  });

  app.post("/api/slots/:id/book", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);
      if (!slot) return res.status(404).send("Slot not found");
      if (slot.isBooked) return res.status(409).send("Slot already booked");

      const updated = await storage.updateSlot(id, {
        isBooked: true,
        studentId: user.id,
      });
      res.json(updated);
    } catch (err) {
      res.status(500).send("Error booking slot");
    }
  });

  // ✅ ZMODYFIKOWANA FUNKCJA ANULOWANIA Z MOCKIEM MAILA
  app.post("/api/slots/:id/cancel", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;

    try {
      const id = parseInt(req.params.id);
      const slot = await storage.getSlot(id);
      if (!slot) return res.status(404).send("Slot not found");

      if (user.role !== "admin" && slot.studentId !== user.id) {
        return res.status(403).send("Not authorized");
      }

      if (user.role !== "admin") {
        const hoursUntilLesson = differenceInHours(
          new Date(slot.startTime),
          new Date()
        );
        if (hoursUntilLesson < 24) {
          return res.status(400).json({
            message: "Too late to cancel. Contact admin directly.",
          });
        }
      }

      const updated = await storage.updateSlot(id, {
        isBooked: false,
        studentId: null,
        isPaid: false,
        topic: null,
      });

      // --- WYSYŁANIE POWIADOMIENIA (LOG W TERMINALU) ---
      const slotDate = new Date(slot.startTime);
      // Wywołujemy naszą funkcję z email.ts
      await sendWaitlistNotification({
        email: "przykladowy@uczen.pl", // Tu w przyszłości wstawimy prawdziwy e-mail
        name: "Oczekujący Uczeń",
        date: format(slotDate, "dd MMMM yyyy", { locale: pl }),
        time: format(slotDate, "HH:mm"),
      });
      // -------------------------------------------------

      res.json(updated);
    } catch (err) {
      res.status(500).send("Error cancelling slot");
    }
  });

  app.post("/api/waitlist", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user as User;
    try {
      const input = insertWaitlistSchema.parse({
        ...req.body,
        userId: user.id,
      });
      const entry = await storage.addToWaitlist(input);
      res.status(201).json(entry);
    } catch (err) {
      res.status(400).json({ message: "Invalid request" });
    }
  });

  if (process.env.NODE_ENV !== "production") {
    const adminUser = await storage.getUserByUsername("admin");
    if (!adminUser) {
      const adminPass = await hashPassword("admin123");
      await storage.createUser({
        username: "admin",
        password: adminPass,
        role: "admin",
        name: "Math Tutor",
      });
    }
  }

  return httpServer;
}
-------------------------------
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { NavBar } from "@/components/nav-bar";
import NotFound from "@/pages/not-found";
import HomePage from "@/pages/home";
import LoginPage from "@/pages/login";
import RegisterPage from "@/pages/register";
import DashboardPage from "@/pages/dashboard";
import AdminPanel from "@/pages/admin";
import BookingPage from "@/pages/booking";
import { ProtectedRoute } from "@/components/protected-route";

function Router() {
  return (
    <>
      <NavBar />
      <Switch>
        <Route path="/" component={HomePage} />
        <Route path="/login" component={LoginPage} />
        <Route path="/register" component={RegisterPage} />

        {/* Protected Routes */}
        <ProtectedRoute path="/dashboard" component={DashboardPage} />
        <ProtectedRoute path="/booking" component={BookingPage} />
        <ProtectedRoute path="/admin" component={AdminPanel} role="admin" />

        {/* Fallback */}
        <Route component={NotFound} />
      </Switch>
    </>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Router />
        <Toaster />
      </TooltipProvider>
    </QueryClientProvider>
  );
}

export default App;


-------------------------------------
PROMPT STANU PROJEKTU (MathMentor)
Kontekst:
Rozwijamy aplikację webową MathMentor (React + Vite, Node.js + Express, Drizzle ORM + Neon DB). System służy do zarządzania korepetycjami z matematyki. Mamy działającą autoryzację (Passport.js), dashboard ucznia i panel admina.
Aktualne zadanie: Wdrożenie "Tygodniowego Szablonu" i Generatora
Zmieniamy logikę z ręcznego dodawania slotów na system oparty o stały plan lekcji.
Ustalenia architektury:
Baza Danych (schema.ts):
Nowa tabela weekly_schedule: przechowuje wzorzec (dzień tygodnia, godzina startu, czas trwania, domyślny uczeń, cena).
Aktualizacja users: dodanie pól admin_notes (notatki prywatne) i default_price (stawka).
Aktualizacja slots/lessons: dodanie price (cena za konkretną lekcję) i admin_notes.
Backend (routes.ts / storage.ts):
Endpointy CRUD dla weekly_schedule.
Generator: Funkcja, która przyjmuje zakres dat, pobiera szablon tygodniowy i generuje sloty.
Święta: Generator musi odpytać zewnętrzne API o święta w Polsce w danym zakresie i pominąć te dni przy generowaniu.
Frontend (admin.tsx):
Nowy widok "Plan Tygodniowy" do edycji szablonu.
Przycisk "Generuj Grafik" z wyborem miesiąca/zakresu.
Zasady współpracy:
User wysyła oryginalny plik.
Agent odsyła kompletny, gotowy do wklejenia plik (bez skrótów ..., bez komentarzy typu "tutaj reszta kodu").
Pracujemy plik po pliku.
------------------------------

Skoro Panel Admina (zarządzanie uczniami, szablonem i generatorem) działa poprawnie, proponuję teraz przejść na stronę Ucznia, aby upewnić się, że system działa z perspektywy klienta.
Dzięki importowi (seed) mamy gotowych uczniów. Warto sprawdzić, czy widzą oni swoje lekcje.
Oto co proponuję zrobić teraz:
1. Test Widoku Ucznia (Weryfikacja danych)
Sprawdźmy, czy import przypisał lekcje do konkretnych kont.
Wyloguj się z konta Admina.
Zaloguj się jako jeden z zaimportowanych uczniów, np.:
Login: masias (lub oskarz, julkab - login to imię i pierwsza litera nazwiska małymi literami, bez polskich znaków).
Hasło: student123 (domyślne hasło z seeda).
Wejdź w Pulpit (Dashboard).
Oczekiwanie: Powinieneś zobaczyć licznik "Następna lekcja za..." oraz listę nadchodzących zajęć wygenerowanych z szablonu.
Wejdź w Kalendarz.
Oczekiwanie: Powinieneś widzieć swoje zajęcia na pomarańczowo, a wolne sloty na biało/szaro.
2. Implementacja Listy Rezerwowej (Waitlist)
W oryginalnych wymaganiach była funkcja: "Jeśli dany dzień nie ma wolnych slotów, pojawia się przycisk 'Powiadom mnie o dostępności'".
Obecnie mamy tabelę w bazie i endpoint API, ale nie mamy tego przycisku na Froncie.
Czy chcesz, abym przygotował kod do obsługi Listy Rezerwowej w pliku booking.tsx?
3. Powiadomienia E-mail (Nodemailer)
System działa, ale "na sucho". Nie wysyła prawdziwych maili.
Czy chcesz teraz skonfigurować serwis e-mail, aby po rezerwacji/anulowaniu przychodziło powiadomienie na prawdziwy adres? (Będziemy potrzebować dostępu do jakiegoś SMTP, np. Gmaila lub Resend, albo zrobimy "mock", który loguje treść maila do konsoli na początek).
Moja rekomendacja:
Zróbmy punkt 2 (Lista Rezerwowa). To domknie funkcjonalności Frontendu dla Ucznia. Potem zajmiemy się mailami.
Co Ty na to?

